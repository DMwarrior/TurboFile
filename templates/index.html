<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æé€Ÿä¼  - é«˜é€Ÿæ–‡ä»¶ä¼ è¾“ç³»ç»Ÿ</title>

    <!-- Favicon - é—ªç”µå›¾æ ‡ -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><path fill='%23ffc107' d='M11.251.068a.5.5 0 0 1 .227.58L9.677 6.5H13a.5.5 0 0 1 .364.843l-8 8.5a.5.5 0 0 1-.842-.49L6.323 9.5H3a.5.5 0 0 1-.364-.843l8-8.5a.5.5 0 0 1 .615-.09z'/></svg>" type="image/svg+xml">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --secondary-color: #f59e0b;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --info-color: #3b82f6;
            --light-bg: #f8fafc;
            --card-bg: #ffffff;
            --border-color: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #744ba2ff 100%);
            --gradient-secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --gradient-success: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container-fluid {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            margin: 2px;
            padding: 6px;
            max-width: calc(100vw - 4px);
            height: calc(100vh - 4px);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .file-browser {
            height: calc(var(--browse-height, 50vh));
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--card-bg);
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
            /* é˜²æ­¢æ»šåŠ¨äº‹ä»¶å†’æ³¡åˆ°çˆ¶å…ƒç´  */
            overscroll-behavior: contain;
            /* ç¡®ä¿æ»šåŠ¨å¹³æ»‘ */
            scroll-behavior: smooth;
            /* è®¾ç½®æ»šåŠ¨æ¡æ ·å¼ */
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
            /* ç¡®ä¿å†…å®¹å¯ä»¥å®Œå…¨æ»šåŠ¨ */
            box-sizing: border-box;
            position: relative;
        }

        .file-browser:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }

        /* WebKitæµè§ˆå™¨æ»šåŠ¨æ¡æ ·å¼ */
        .file-browser::-webkit-scrollbar {
            width: 8px;
        }

        .file-browser::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 4px;
        }

        .file-browser::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .file-browser::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        .file-item {
            cursor: pointer;
            padding: 4px 8px;
            border-bottom: 1px solid #f1f5f9;
            font-size: 0.8rem;
            line-height: 1.3;
            user-select: none;
            display: flex;
            align-items: center;
            /* å®Œå…¨ç§»é™¤transitionåŠ¨ç”» */
            border-radius: 3px;
            margin: 0px 1px 0px 1px;
            /* ç¡®ä¿æœ€åä¸€ä¸ªæ–‡ä»¶é¡¹æœ‰è¶³å¤Ÿçš„åº•éƒ¨é—´è· */
            min-height: 28px;
        }

        .file-item:hover {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            /* ç§»é™¤transformåŠ¨ç”»ï¼Œä¿æŒé™æ€æ‚¬åœæ•ˆæœ */
            box-shadow: var(--shadow-sm);
        }

        .file-item.selected {
            background: #cce8ff; /* Windows é€‰ä¸­æ·¡è“ */
            color: #111827;
            box-shadow: none;
            border: 1px solid #99caff;
        }

        .file-item.selected:hover {
            background: #cce8ff;
            color: #111827;
            box-shadow: none;
        }

        .file-item i {
            margin-right: 6px;
            width: 14px;
            text-align: center;
            font-size: 0.75rem;
        }

        .file-info {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-name {
            flex: 1;
            font-weight: 500;
        }

        .file-details {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-left: 8px;
            font-weight: 400;
        }

        .file-item.selected .file-details {
            opacity: 0.9;
        }

        /* è·¯å¾„æ å†…è”ç¼–è¾‘æ ·å¼ï¼ˆå¤–è§‚ä¿æŒä¸€è‡´ï¼Œä»…æ”¯æŒé€‰ä¸­/ç²˜è´´/å›è½¦è·³è½¬ï¼‰ */
        .path-inline-editor {
            min-width: 160px;
            display: inline-block;
            outline: none;
            border: none;
            background: transparent;
            color: var(--text-primary);
            font-size: inherit;
        }

        /* æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆVS Code é£æ ¼å°ºå¯¸ä¸é…è‰²ï¼‰ */
        .editor-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1050;
        }
        .editor-dialog {
            position: absolute;
            top: 5vh;
            left: 50%;
            transform: translateX(-50%);
            width: 95vw;
            max-width: 1400px;
            height: 90vh;
            background: #272b33;
            color: #e6e8eb;
            border-radius: 8px;
            box-shadow: 0 18px 40px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
        }
        .editor-header {
            padding: 10px 14px;
            border-bottom: 1px solid #323741;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #2f343d;
        }
        .editor-body {
            flex: 1;
            overflow: hidden;
            display: flex;
            background: #23272f;
        }
        .editor-text-wrapper {
            position: relative;
            flex: 1;
        }
        .editor-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .editor-textarea {
            width: 100%;
            height: 100%;
            padding: 12px 14px;
            background: #23272f;
            color: #e6e8eb;
            border: none;
            outline: none;
            resize: none;
            font-family: 'Consolas','Menlo','Monaco','Courier New',monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre;
            overflow: auto;
            tab-size: 4;
            scrollbar-color: #3a3a3a #1e1e1e;
            position: relative;
            z-index: 2;
            background: transparent; /* ä¸‹å±‚é«˜äº®èƒŒæ™¯é€å‡º */
        }
        .editor-highlight-layer {
            position: absolute;
            inset: 0;
            margin: 0;
            padding: 12px 14px;
            background: #23272f;
            color: transparent !important; /* ä»…ä¿ç•™èƒŒæ™¯é«˜äº® */
            pointer-events: none;
            white-space: pre;
            font-family: 'Consolas','Menlo','Monaco','Courier New',monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow: hidden;
            tab-size: 4;
            z-index: 1; /* ä½äº textarea ä¸‹å±‚ */
        }
        .editor-highlight-layer .hl {
            background: transparent;
            color: transparent !important;
            border-radius: 0;
            padding: 0;
        }

        .progress-container {
            display: none;
        }

        /* Sublime é£æ ¼ minimap */
        /* æŸ¥æ‰¾/æ›¿æ¢é¢æ¿ */
        .find-replace-bar {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            background: #2f343d;
            border-top: 1px solid #3a404c;
            padding: 6px 10px;
            display: none;
            gap: 6px;
            align-items: center;
            z-index: 10;
        }
        .find-replace-bar input {
            background: #22262e;
            border: 1px solid #3a404c;
            color: #e6e8eb;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 12px;
            min-width: 200px;
        }
        .find-replace-bar button {
            border: none;
            background: #3b82f6;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .find-replace-bar .secondary {
            background: #4b5563;
        }

	        /* å›¾ç‰‡ç½‘æ ¼è§†å›¾ */
	        #imageGridModal {
	            background: #11161f;
	            padding: 0 !important; /* è¦†ç›–å†…è” paddingï¼Œè®©æ ‡é¢˜æ è´´é¡¶ */
	        }
	        .image-grid-header {
	            display: flex;
	            justify-content: space-between;
	            align-items: center;
	            position: sticky;
	            top: 0;
	            z-index: 2;
	            background: #11161f;
	            border-bottom: 1px solid rgba(148,163,184,0.12);
	            padding: 6px 16px;
	            margin-bottom: 8px;
	            color: #e5e7eb;
	            gap: 10px;
	        }
	        .image-grid-header-left {
	            display: flex;
	            align-items: center;
	            gap: 12px;
	            min-width: 0;
	        }
	        .image-grid-title {
	            font-weight: 600;
	            font-size: 14px;
	            line-height: 1.2;
	            white-space: nowrap;
	        }
	        .image-grid-cols-control {
	            display: flex;
	            align-items: center;
	            gap: 8px;
	            padding: 4px 8px;
	            border-radius: 10px;
	            background: rgba(255,255,255,0.03);
	            border: 1px solid rgba(148,163,184,0.15);
	        }
	        .image-grid-cols-label {
	            color: #9ca3af;
	            font-size: 12px;
	            font-weight: 600;
	            letter-spacing: 0.2px;
	            white-space: nowrap;
	        }
	        .image-grid-cols-buttons {
	            display: flex;
	            align-items: center;
	            gap: 8px;
	        }
	        .image-grid-cols-btn {
	            border: none;
	            background: transparent;
	            color: #cbd5e1;
	            padding: 3px 5px;
	            border-radius: 6px;
	            font-size: 12px;
	            font-weight: 600;
	            line-height: 1.2;
	            cursor: pointer;
	            transition: background 120ms ease, color 120ms ease;
	        }
	        .image-grid-close-btn {
	            padding: 4px 10px;
	        }
	        .image-grid-cols-btn:hover {
	            background: rgba(255,255,255,0.06);
	            color: #e5e7eb;
	        }
	        .image-grid-cols-btn.active {
	            background: rgba(59,130,246,0.14);
	            color: #93c5fd;
	        }
	        /* é¢„è§ˆå±‚åœ¨ç½‘æ ¼ä¹‹ä¸Šï¼Œç¡®ä¿ESCåªå…³é—­é¢„è§ˆï¼Œä¸å½±å“ç½‘æ ¼ */
	        #imagePreviewModal {
	            z-index: 1100 !important;
	        }
	        #imageGridContainer {
	            display: grid;
	            --image-grid-cols: 8;
	            grid-template-columns: repeat(var(--image-grid-cols), minmax(0, 1fr));
	            gap: 12px;
	            padding: 0 16px 16px;
	            box-sizing: border-box;
	            will-change: grid-template-columns;
	        }
	        .image-grid-card {
	            background: #1b2230;
            border: 1px solid #222b3a;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            cursor: pointer;
            transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
        }
        .image-grid-card:hover {
            transform: translateY(-2px);
            border-color: #3b82f6;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
	        }
	        .image-grid-card img {
	            width: 100%;
	            height: auto;
	            aspect-ratio: 220 / 150;
	            object-fit: contain;
	            background: #0f172a;
	            border-radius: 8px;
	        }
        .image-grid-name {
            font-size: 12px;
            color: #e5e7eb;
            word-break: break-all;
            text-align: center;
        }
        .image-grid-empty {
            color: #9ca3af;
            font-size: 13px;
            text-align: center;
            grid-column: 1/-1;
            padding: 20px 0;
        }
	        @media (max-width: 768px) {
	            .image-grid-header {
	                flex-wrap: wrap;
	            }
	            .image-grid-cols-control {
	                width: 100%;
	                justify-content: space-between;
	            }
	        }

        /* VSCode é£æ ¼ Diff æ¨¡æ€æ¡† */
        #diffModal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1200;
            display: none;
        }
        .diff-dialog {
            position: absolute;
            top: 4vh;
            left: 50%;
            transform: translateX(-50%);
            width: 96vw;
            max-width: 1600px;
            height: 90vh;
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 8px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.45);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid #2a2a2a;
        }
        .diff-header {
            background: #252526;
            border-bottom: 1px solid #2d2d2d;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #9cdcfe;
        }
        .diff-header .paths {
            display: flex;
            gap: 12px;
            align-items: center;
            color: #9cdcfe;
        }
        .diff-close-btn {
            background: #3a3d41;
            border: 1px solid #4b4d50;
            color: #d4d4d4;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.2;
        }
        .diff-close-btn:hover {
            background: #45484d;
        }
        .diff-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .diff-grid {
            flex: 1;
            overflow: auto;
            padding: 10px;
        }
        .diff-rows {
            display: flex;
            flex-direction: column;
            gap: 1px;
            font-family: 'Consolas','Menlo','Monaco','Courier New', monospace;
            font-size: 13px;
        }
        .diff-line {
            display: flex;
            background: #1e1e1e;
            border-bottom: 1px solid #2a2a2a;
        }
        .diff-side {
            flex: 1;
            display: grid;
            grid-template-columns: 54px 1fr;
            min-height: 20px;
        }
        .diff-lineno {
            background: transparent;
            color: #858585;
            padding: 2px 6px;
            text-align: right;
            user-select: none;
            border-right: 1px solid #2a2a2a;
        }
        .diff-code {
            padding: 2px 8px;
            white-space: pre;
            overflow: hidden;
            background: transparent;
            color: #d4d4d4;
        }
        .diff-line.equal .diff-code {
            background: #1e1e1e;
        }
        .diff-line.insert .diff-side.right .diff-code,
        .diff-line.insert .diff-side.right .diff-lineno {
            background: #294436;
            border-left: 3px solid #4b8b3b;
        }
        .diff-line.delete .diff-side.left .diff-code,
        .diff-line.delete .diff-side.left .diff-lineno {
            background: #5d2626;
            border-left: 3px solid #f14c4c;
        }
        .diff-line.replace .diff-side.left .diff-code,
        .diff-line.replace .diff-side.left .diff-lineno,
        .diff-line.replace .diff-side.right .diff-code,
        .diff-line.replace .diff-side.right .diff-lineno {
            background: #42321d;
            border-left: 3px solid #c5a332;
        }
        .diff-summary {
            padding: 6px 12px;
            background: #252526;
            border-top: 1px solid #2d2d2d;
            font-size: 12px;
            color: #9cdcfe;
        }

        .server-panel {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 3px 5px;
            margin-bottom: 2px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .server-panel:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }



        /* æ‹–æ‹½ç›¸å…³æ ·å¼ - ç§»é™¤transformåŠ¨ç”» */
        /* æ‹–æ‹½ç›¸å…³æ ·å¼å·²ç§»é™¤ä»¥æå‡æ€§èƒ½ */

        /* åŠ è½½çŠ¶æ€æ ·å¼å·²ç§»é™¤ï¼Œå®ç°æ— æ„ŸåŒå‡» */

        /* é”™è¯¯çŠ¶æ€æ ·å¼ */
        .error-state {
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            border: 1px solid #fecaca;
            border-radius: 8px;
        }

        /* è¿”å›ä¸Šçº§ç›®å½•æ ·å¼ä¼˜åŒ– */
        .file-item[title*="åŒå‡»è¿”å›"] {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border: 1px solid #bfdbfe;
            margin-bottom: 4px;
        }

        .file-item[title*="åŒå‡»è¿”å›"]:hover {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            /* ç§»é™¤transformåŠ¨ç”»ï¼Œä¿æŒé™æ€æ‚¬åœæ•ˆæœ */
            box-shadow: var(--shadow-md);
        }

        /* å®Œå…¨ç§»é™¤activeçŠ¶æ€åŠ¨ç”»æ•ˆæœ */
        .file-item:active {
            /* ç§»é™¤æ‰€æœ‰transformå’ŒtransitionåŠ¨ç”» */
        }

        /* ç¡®ä¿æœ€åä¸€ä¸ªæ–‡ä»¶é¡¹æœ‰è¶³å¤Ÿçš„åº•éƒ¨é—´è· */
        .file-item:last-child {
            margin-bottom: 8px;
        }

        /* åˆ·æ–°çŠ¶æ€åŠ¨ç”»å·²ç§»é™¤ */

        /* åˆ·æ–°æŒ‰é’®æ ·å¼ä¼˜åŒ– */
        .btn-outline-primary:hover, .btn-outline-success:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .btn-outline-primary:active, .btn-outline-success:active {
            transform: translateY(0);
        }

        /* ä¿®å¤åˆ·æ–°æŒ‰é’®ç„¦ç‚¹çŠ¶æ€é˜´å½±æŒç»­é—®é¢˜ */
        .btn-outline-primary:focus, .btn-outline-success:focus {
            box-shadow: none !important;
            transform: none !important;
        }

        .btn-outline-primary:focus:not(:hover), .btn-outline-success:focus:not(:hover) {
            box-shadow: none !important;
            transform: none !important;
            border-color: var(--border-color) !important;
        }

        /* åˆ·æ–°æŒ‰é’®é¢œè‰²äº¤äº’è¡Œä¸ºä¿®å¤ä¸ä¼˜åŒ–ï¼ˆä»…é™æ–‡ä»¶æµè§ˆå™¨åŒºåŸŸï¼‰ */
        /* æ‚¬åœæ—¶ä¸å˜è‰²ï¼Œä»…ä¿ç•™æˆ‘ä»¬å·²æœ‰çš„è½»å¾®æµ®èµ·ä¸é˜´å½±åé¦ˆ */
        #sourcePanel .btn-outline-primary,
        #targetPanel .btn-outline-success {
            /* ä¸ºç‚¹å‡»åé¦ˆæä¾›å¹³æ»‘è¿‡æ¸¡ */
            transition: background-color 120ms ease, color 120ms ease, box-shadow 120ms ease, transform 120ms ease;
        }

        #sourcePanel .btn-outline-primary:hover {
            background-color: transparent !important;
            color: var(--primary-color) !important;
            border-color: var(--primary-color) !important;
        }
        #targetPanel .btn-outline-success:hover {
            background-color: transparent !important;
            color: var(--success-color) !important;
            border-color: var(--success-color) !important;
        }

        /* ç‚¹å‡»æŒ‰ä¸‹æ—¶æ˜ç¡®çš„é¢œè‰²åé¦ˆï¼Œæ¾å¼€åè¿…é€Ÿæ¢å¤ */
        #sourcePanel .btn-outline-primary:active {
            background-color: var(--primary-dark) !important;
            color: #fff !important;
            border-color: var(--primary-dark) !important;
        }
        #targetPanel .btn-outline-success:active {
            background-color: var(--success-color) !important;
            color: #fff !important;
            border-color: var(--success-color) !important;
        }

        /* ç„¦ç‚¹ä½†éæŒ‰ä¸‹/æ‚¬åœæ—¶ä¿æŒåŸå§‹å¤–è§‚ï¼Œé¿å…æ®‹ç•™å˜è‰² */
        #sourcePanel .btn-outline-primary:focus:not(:active):not(:hover) {
            background-color: transparent !important;
            color: var(--primary-color) !important;
            border-color: var(--primary-color) !important;
        }
        #targetPanel .btn-outline-success:focus:not(:active):not(:hover) {
            background-color: transparent !important;
            color: var(--success-color) !important;
            border-color: var(--success-color) !important;
        }


        /* å¼ºåˆ¶ä¿æŒé»˜è®¤å…‰æ ‡æ ·å¼ */
        body, html {
            cursor: default !important;
        }

        .file-item, .file-item * {
            cursor: pointer !important;
        }

        .path-segment, .path-segment * {
            cursor: pointer !important;
        }

        .resizer {
            cursor: col-resize !important;
        }

        body.browsing .path-segment, body.browsing .path-segment * {
            cursor: pointer !important;
        }

        .drag-preview {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            background: var(--gradient-primary);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(10px);
        }

        /* Windows é£æ ¼å³é”®èœå• */
        .file-context-menu {
            position: fixed;
            display: none;
            min-width: 180px;
            background: #fdfdfd;
            border: 1px solid #d9e2ec;
            border-radius: 6px;
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.18);
            padding: 4px 0;
            z-index: 2000;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .file-context-menu .menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            cursor: pointer;
            line-height: 1.2;
        }

        .file-context-menu .menu-item:hover {
            background: linear-gradient(135deg, #e7f1ff 0%, #dbeafe 100%);
        }

        .file-context-menu .menu-item.disabled {
            color: var(--text-secondary);
            cursor: not-allowed;
            background: transparent;
        }

        .file-context-menu .menu-item i {
            width: 16px;
            text-align: center;
            font-size: 0.95rem;
        }

        /* åˆ†éš”æ¡æ ·å¼ */
        .resizer {
            background: linear-gradient(135deg, var(--border-color) 0%, #cbd5e1 100%);
            cursor: col-resize;
            width: 8px;
            position: relative;
            transition: all 0.3s ease;
            border-radius: 4px;
        }

        .resizer:hover {
            background: var(--gradient-primary);
            transform: scaleX(1.2);
        }



        /* è·¯å¾„å¯¼èˆªæ ·å¼ */
        .path-nav {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 4px 8px;
            margin-bottom: 8px;
            font-size: 0.875rem;
            font-family: 'JetBrains Mono', monospace;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .path-nav:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }

        .path-segment {
            color: var(--primary-color);
            cursor: pointer;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            padding: 1px 2px;
            border-radius: 4px;
        }

        .path-segment:hover {
            background: var(--primary-color);
            color: white;
            text-decoration: none;
        }

        .path-separator {
            margin: 0 3px;
            color: var(--text-secondary);
            font-weight: 300;
        }

        /* è°ƒæ•´å®¹å™¨å¸ƒå±€ */
        .resizable-container {
            display: flex;
            height: 100%;
            gap: 8px;
        }

        .resizable-panel {
            overflow: visible;
            background: var(--card-bg);
            border-radius: 6px;
            padding: 3px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
            /* ç¡®ä¿é¢æ¿å†…çš„æ»šåŠ¨ä¸å½±å“å¤–éƒ¨ */
            position: relative;
        }

        .resizable-panel:hover {
            box-shadow: var(--shadow-md);
        }
        /* ç°ä»£åŒ–æŒ‰é’®æ ·å¼ */
        .btn {
            border-radius: 4px;
            font-weight: 500;
            padding: 6px 12px;
            transition: all 0.3s ease;
            border: none;
            box-shadow: var(--shadow-sm);
            font-size: 0.9rem;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--gradient-primary);
            filter: brightness(1.1);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            filter: brightness(1.1);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            color: white;
        }

        .btn-outline-secondary {
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            background: var(--card-bg);
        }

        .btn-outline-secondary:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        /* è¡¨å•æ§ä»¶æ ·å¼ */
        .form-select, .form-control {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 5px 8px;
            transition: all 0.3s ease;
            background: var(--card-bg);
            font-size: 0.9rem;
        }

        .form-select:focus, .form-control:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
            background: var(--card-bg);
        }

        /* å¡ç‰‡æ ·å¼ */
        .card {
            border: none;
            border-radius: 16px;
            box-shadow: var(--shadow-md);
            background: var(--card-bg);
            transition: all 0.3s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        .card-body {
            padding: 4px 6px;
        }

        /* è¿›åº¦æ¡æ ·å¼ */
        .progress {
            border-radius: 10px;
            background: var(--light-bg);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .progress-bar {
            background: var(--gradient-success);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .progress-bar-animated {
            animation: progress-bar-stripes 1s linear infinite;
        }

        /* æ ‡é¢˜æ ·å¼ */
        h4, h6 {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
            margin-top: 1px;
        }

        .main-title {
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.1rem;
            font-weight: 700;
            margin: 0;
            line-height: 1;
            display: flex;
            align-items: center;
        }

        /* å…¬å¸å“ç‰Œæ•´ä½“æ ·å¼ */
        .company-brand {
            transition: all 0.3s ease;
            filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.1));
            display: flex;
            align-items: center;
            height: 32px; /* ä¸æ ‡é¢˜é«˜åº¦ä¸€è‡´ */
        }

        .company-brand:hover {
            transform: scale(1.03);
            filter: drop-shadow(0 2px 6px rgba(20, 184, 166, 0.2));
        }

        .company-brand svg {
            vertical-align: middle;
        }

        /* äº§å“å“ç‰Œæ•´ä½“æ ·å¼ */
        .product-brand {
            display: flex;
            align-items: center;
            height: 32px;
        }





        /* å“åº”å¼å“ç‰Œè°ƒæ•´ */
        @media (max-width: 768px) {
            .company-brand {
                height: 26px;
                margin-right: 30px !important;
            }

            .company-brand svg {
                width: 130px;
                height: 26px;
            }

            .product-brand {
                height: 26px;
                margin-left: 12px !important;
            }

            .main-title {
                font-size: 1.0rem;
            }
        }

        @media (max-width: 480px) {
            .company-brand {
                height: 22px;
                margin-right: 20px !important;
            }

            .company-brand svg {
                width: 110px;
                height: 22px;
            }

            .product-brand {
                height: 22px;
                margin-left: 10px !important;
            }

            .main-title {
                font-size: 0.9rem;
            }
        }

        /* ç¡®ä¿å®Œå…¨å•å±æ˜¾ç¤º */
        .flex-shrink-0 {
            flex-shrink: 0;
        }

        .flex-grow-1 {
            flex-grow: 1;
            min-height: 0;
        }

        /* é˜²æ­¢æ»šåŠ¨å†²çªçš„é¢å¤–æ ·å¼ */
        .resizable-container {
            /* ç¡®ä¿å®¹å™¨ä¸ä¼šäº§ç”Ÿæ»šåŠ¨æ¡ */
            overflow: hidden;
            /* é˜²æ­¢æ»šåŠ¨äº‹ä»¶ä¼ æ’­ */
            overscroll-behavior: contain;
        }

        /* ç¡®ä¿æ–‡ä»¶æµè§ˆå™¨åŒºåŸŸçš„æ»šåŠ¨ç‹¬ç«‹æ€§ */
        #sourceFileBrowser, #targetFileBrowser {
            /* é˜²æ­¢æ»šåŠ¨äº‹ä»¶å†’æ³¡ */
            overscroll-behavior: contain;
            /* ç¡®ä¿æ»šåŠ¨åŒºåŸŸæ˜ç¡®å®šä¹‰ */
            position: relative;
            /* ä¼˜åŒ–æ»šåŠ¨æ€§èƒ½ */
            will-change: scroll-position;
            /* ç¡®ä¿æ»šåŠ¨åˆ°åº•éƒ¨æ—¶æœ‰è¶³å¤Ÿçš„ç©ºé—´ */
            scroll-padding-bottom: 20px;
        }

        /* ä¸‹è½½åˆ°Windowså¼¹çª—ï¼ˆç²¾ç®€ç‰ˆï¼‰ */
        .download-win-dialog {
            position: fixed;
            margin: 0;
            width: 420px;
            max-width: calc(100vw - 16px);
            max-height: calc(100vh - 16px);
            transform: none;
        }

        .download-win-modal {
            font-size: 0.8rem;
        }

        .download-win-modal .modal-title {
            font-size: 0.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .download-win-modal .modal-header {
            padding: 8px 12px;
        }

        .download-win-modal .modal-body {
            padding: 10px 12px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .download-win-modal .modal-footer {
            padding: 8px 12px 12px;
            border-top: 1px solid var(--border-color);
        }

        .download-win-modal .form-select,
        .download-win-modal .btn {
            font-size: 0.8rem;
        }

        .download-win-drive-row .form-label {
            white-space: nowrap;
        }

        .download-win-drive {
            min-width: 110px;
            max-width: 160px;
        }

        .download-win-list {
            flex: 1 1 auto;
            min-height: 45vh;
            max-height: 70vh;
            overflow: auto;
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .download-win-list .list-group-item {
            padding: 4px 8px;
            border: 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .download-win-list .list-group-item:last-child {
            border-bottom: 0;
        }

        .download-win-list .list-group-item.active {
            background: #e2e8f0;
            color: var(--text-primary);
        }

        @media (max-width: 576px) {
            .download-win-dialog {
                width: calc(100vw - 16px);
                max-width: calc(100vw - 16px);
                margin: 8px auto;
            }

            .download-win-list {
                min-height: 40vh;
                max-height: 70vh;
            }

            .download-win-drive {
                max-width: 100%;
            }
        }

        /* æ¨¡æ€çª—å£ä¸­çš„æ—¥å¿—åŒºåŸŸæ ·å¼ */
        #logModal .modal-dialog {
            max-width: 60vw;
        }

        #logModal .modal-body {
            max-height: Â·70vh;
        }

        .log-container {
            height: 70vh;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: #f8f9fa;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            overscroll-behavior: contain;
            scroll-behavior: smooth;
        }

        .log-content {
            padding: 8px 12px;
            min-height: 100%;
        }

        .log-entry {
            margin-bottom: 3px;
            padding: 3px 6px;
            border-radius: 4px;
            word-wrap: break-word;
            animation: logFadeIn 0.3s ease-in;
        }

        .log-entry .log-message,
        .log-entry .log-run-block {
            white-space: pre-wrap;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        .log-entry .log-run-block {
            margin: 2px 0 0 0;
            padding: 0;
            background: transparent;
            border: none;
        }

        .log-entry.log-info {
            color: #0066cc;
            background: rgba(0, 102, 204, 0.08);
        }

        .log-entry.log-success {
            color: #28a745;
            background: rgba(40, 167, 69, 0.08);
        }

        .log-entry.log-warning {
            color: #ffc107;
            background: rgba(255, 193, 7, 0.12);
        }

        .log-entry.log-error {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.12);
        }

        .log-timestamp {
            color: #6c757d;
            font-size: 0.75rem;
            margin-right: 8px;
        }

        @keyframes logFadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* æ¨¡æ€çª—å£æ—¥å¿—æ»šåŠ¨æ¡æ ·å¼ */
        .log-container::-webkit-scrollbar {
            width: 8px;
        }

        .log-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .log-container::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        /* è·¯å¾„å¯¼èˆªä¼˜åŒ– */
        .path-nav {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 2px 4px;
            margin-bottom: 2px;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            box-shadow: var(--shadow-sm);
        }

        /* Windows ç£ç›˜ä¸‹æ‹‰è§†è§‰ä¼˜åŒ–ï¼šæ›´å°å­—ä½“ï¼Œé£æ ¼ä¸æ•´ä½“èåˆ */
        .path-nav .dropdown-toggle {
            font-size: 0.80rem; /* ä¸è·¯å¾„æ®µæ¥è¿‘çš„å­—å·ï¼Œé¿å…çªå…€ */
            padding: 1px 4px;
            line-height: 1.2;
        }
        .path-nav .dropdown-menu {
            font-size: 0.85rem; /* ä¸‹æ‹‰é¡¹ç•¥å¤§äºè·¯å¾„æ®µï¼Œä¾¿äºé˜…è¯» */
            padding: 4px 0;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
        }
        .path-nav .dropdown-item {
            padding: 4px 10px;
            line-height: 1.25;
        }
        .path-nav .dropdown-item.active,
        .path-nav .dropdown-item:active {
            background-color: #eef2ff;
            color: #111827;
        }


        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .container-fluid {
                margin: 1px;
                padding: 4px;
                border-radius: 6px;
            }

            .resizable-container {
                flex-direction: column;
                gap: 4px;
            }

            .resizable-panel {
                padding: 3px;
            }

            .main-title {
                font-size: 1.0rem;
                margin: 0;
            }

            .server-panel {
                padding: 3px 5px;
                margin-bottom: 2px;
            }

            .file-item {
                padding: 3px 5px;
                font-size: 0.75rem;
                min-height: 24px;
            }

            .btn {
                font-size: 0.85rem;
                padding: 5px 10px;
            }
        }

        /* è¶…å°å±å¹•ä¼˜åŒ– */
        @media (max-width: 576px) {
            .col-md-6 {
                padding-left: 3px;
                padding-right: 3px;
            }

            .input-group .btn {
                padding: 4px 8px;
                font-size: 0.8rem;
            }

            .main-title {
                font-size: 0.9rem;
                margin: 0;
            }

            .file-item {
                font-size: 0.7rem;
                padding: 2px 4px;
                min-height: 20px;
            }
        }

        /* é«˜åº¦é™åˆ¶ä¼˜åŒ– */
        @media (max-height: 800px) {
            .main-title {
                font-size: 0.95rem;
                margin: 0;
            }

            .server-panel {
                padding: 2px 4px;
                margin-bottom: 1px;
            }

            .card-body {
                padding: 3px 5px;
            }

            .file-item {
                padding: 3px 5px;
                min-height: 24px;
            }

            .btn {
                padding: 4px 8px;
                font-size: 0.85rem;
            }
        }

        /* ä¼ è¾“æ¨¡å¼é€‰æ‹©å™¨æ ·å¼ï¼šç¦ç”¨æ‚¬åœåŠ æ·±ï¼Œå¹¶ä¿æŒç‹¬ç«‹åœ†è§’æ¨¡å— */
        .transfer-mode-btn {
            padding: 6px 12px;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 8px !important; /* ç‹¬ç«‹åœ†è§’ */
            transition: none !important;   /* ç¦ç”¨è¿‡æ¸¡å¯¼è‡´çš„åŠ æ·±åŠ¨ç”» */
            box-shadow: none;              /* é»˜è®¤æ— é˜´å½± */
        }
        /* æ‚¬åœ/æŒ‰ä¸‹æ—¶ä¸è¦åŠ æ·±é¢œè‰²ï¼Œä¸æ”¹å˜èƒŒæ™¯ï¼Œä»…ä¿æŒæè¾¹ä¸æ–‡å­—é¢œè‰² */
        .transfer-mode-btn:hover,
        .transfer-mode-btn:active {
            /*    ä¿æŒä¸é»˜è®¤ä¸€è‡´ï¼Œä¸åŠ æ·±è‰² */
            background-color: transparent !important;
            color: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            box-shadow: none !important;
        }
        /* é€‰ä¸­æ€éœ€ç«‹å³é«˜äº®ï¼Œä¸”åœ¨ hover/active çŠ¶æ€ä¸‹ä¹Ÿä¿æŒé«˜äº®ï¼ˆé¿å…éœ€è¦ç§»å¼€é¼ æ ‡æ‰å˜è‰²ï¼‰ */
        .btn-check:checked + .transfer-mode-btn,
        .btn-check:checked + .transfer-mode-btn:hover,
        .btn-check:checked + .transfer-mode-btn:active {
            background: var(--gradient-primary) !important;
            color: #fff !important;
            border-color: transparent !important;
            box-shadow: none !important;
        }


    </style>
</head>
<body>
    <div class="container-fluid" style="position: relative;">


        <!-- æ ‡é¢˜åŒºåŸŸ -->
        <div class="row flex-shrink-0" style="margin-bottom: 2px;">
            <div class="col-12">
                <div class="d-flex align-items-center justify-content-center">
                    <!-- TAIHOå…¬å¸æ•´ä½“ (LOGO + TAIHO + æ³°ç¦¾) -->
                    <div class="company-brand d-flex align-items-center" style="margin-right: 40px;">
                        <svg width="160" height="32" viewBox="0 0 160 36" xmlns="http://www.w3.org/2000/svg">
                            <!-- TAIHOæ ‡å¿—æ€§å‡ ä½•å›¾å½¢ -->
                            <g>
                                <!-- å·¦ä¾§å›¾æ ‡ - ç°ä»£åŒ–å‡ ä½•è®¾è®¡ -->
                                <rect x="2" y="6" width="10" height="24" fill="#14b8a6" rx="2"/>
                                <rect x="16" y="6" width="10" height="24" fill="#0891b2" rx="2"/>
                                <!-- è¿æ¥å…ƒç´  -->
                                <circle cx="7" cy="9" r="2" fill="#06b6d4"/>
                                <circle cx="21" cy="9" r="2" fill="#0284c7"/>

                                <!-- TAIHOæ–‡å­— - ä¸LOGOä¿æŒç›¸åŒè·ç¦»ï¼Œä½¿ç”¨ä¸æ³°ç¦¾ç›¸åŒçš„é¢œè‰² -->
                                <text x="32" y="26" font-family="'Segoe UI', Arial, sans-serif" font-size="18" font-weight="700" fill="#14b8a6">TAIHO</text>
                                <!-- æ³°ç¦¾æ–‡å­— - ä¸TAIHOä¿æŒä¸LOGOåˆ°TAIHOç›¸åŒçš„è·ç¦» -->
                                <text x="102" y="26" font-family="'Microsoft YaHei', sans-serif" font-size="18" font-weight="700" fill="#14b8a6">æ³°ç¦¾</text>
                            </g>
                        </svg>
                    </div>

                    <!-- æé€Ÿä¼ æ ‡é¢˜æ•´ä½“ - ä¸ç›®æ ‡æœåŠ¡å™¨å·¦è¾¹å¯¹é½ -->
                    <div class="product-brand d-flex align-items-center" style="margin-left: 15px;">
                        <h4 class="main-title d-flex align-items-center" style="margin: 0; line-height: 1;">
                            <i class="bi bi-lightning-charge-fill" style="color: #ffc107; font-size: 1.0em; margin-right: 6px;"></i>
                            <span>æé€Ÿä¼ </span>
                        </h4>
                    </div>
                </div>
            </div>
        </div>

        <!-- æœåŠ¡å™¨é€‰æ‹©é¢æ¿ -->
        <div class="row g-1 flex-shrink-0" style="margin-bottom: 3px;">
            <div class="col-md-6">
                <div class="server-panel" style="padding: 4px 6px;">
                    <h6 style="font-size: 0.85rem; margin-bottom: 2px;">
                        <i class="bi bi-hdd-network-fill text-primary"></i> å·¦ä¾§æœåŠ¡å™¨
                    </h6>
                    <select id="sourceServer" class="form-select" style="font-size: 0.85rem;">
                        <option value="" disabled selected hidden>ğŸ” è¯·é€‰æ‹©æºæœåŠ¡å™¨</option>
                        {% for ip, info in servers.items() %}
                        {% if info.get('os_type') != 'windows' or is_admin_client or (client_ipv4 and ip == client_ipv4) %}
                        <option value="{{ ip }}">ğŸ–¥ï¸ {{ info.name }} ({{ ip }})</option>
                        {% endif %}
                        {% endfor %}
                    </select>
                </div>
            </div>
            <div class="col-md-6">
                <div class="server-panel" style="padding: 4px 6px;">
                    <h6 style="font-size: 0.85rem; margin-bottom: 2px;">
                        <i class="bi bi-cloud-upload-fill text-success"></i> å³ä¾§æœåŠ¡å™¨
                    </h6>
                    <select id="targetServer" class="form-select" style="font-size: 0.85rem;">
                        <option value="" disabled selected hidden>ğŸ¯ è¯·é€‰æ‹©æœåŠ¡å™¨</option>
                        {% for ip, info in servers.items() %}
                        {% if info.get('os_type') != 'windows' or is_admin_client or (client_ipv4 and ip == client_ipv4) %}
                        <option value="{{ ip }}">ğŸ–¥ï¸ {{ info.name }} ({{ ip }})</option>
                        {% endif %}
                        {% endfor %}
                    </select>
                </div>
            </div>
        </div>

        <!-- æ–‡ä»¶æµè§ˆå™¨ -->
        <div class="row flex-grow-1" style="min-height: 0;">
            <div class="resizable-container" style="height: 100%;">
                <div class="resizable-panel" id="sourcePanel" style="width: 50%; height: 100%;">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <h6 style="font-size: 0.9rem; margin-bottom: 0;">
                            <i class="bi bi-files text-info"></i> å·¦ä¾§æ–‡ä»¶æµè§ˆ
                        </h6>
                        <div class="d-flex align-items-center" style="gap: 10px;">
                            <small id="sourceFileCount" style="font-size: 0.75rem; color: #64748b;">å…± 0 é¡¹</small>
                            <small id="sourceSelectedInfo" style="font-size: 0.75rem; color: #0d6efd; display: none;"></small>
                            <button class="btn btn-outline-primary btn-sm" onclick="refreshSource()" title="åˆ·æ–°ç›®å½•å†…å®¹" style="font-size: 0.75rem; padding: 2px 6px;">
                                <i class="bi bi-arrow-clockwise"></i> åˆ·æ–°
                            </button>
                            <div class="form-check form-switch" style="font-size: 0.75rem;">
                                <input class="form-check-input" type="checkbox" id="sourceShowHidden" onchange="toggleHiddenFiles('source')">
                                <label class="form-check-label" for="sourceShowHidden" style="font-size: 0.75rem;">
                                    æ˜¾ç¤ºéšè—æ–‡ä»¶
                                </label>
                            </div>
                        </div>
                    </div>
                    <div id="sourcePathNav" class="path-nav" style="display: none; padding: 3px 8px; font-size: 0.8rem; position: relative;" onclick="maybeStartPathInlineEdit(event, true)">
                        <i class="bi bi-geo-alt-fill text-primary me-1"></i>
                        <span id="sourcePathDisplay">/</span>
                        <div style="position:absolute; right:6px; top:50%; transform: translateY(-50%); display: flex; gap: 2px;">
                            <button type="button" class="btn btn-sm" title="åˆ é™¤é€‰ä¸­é¡¹"
                                    onclick="deleteSelected('source')"
                                    style="padding:0 4px; background: transparent; border: none; border-radius:4px;">
                                <i class="bi bi-trash text-danger" style="font-size: 0.85rem;"></i>
                            </button>
                            <button type="button" class="btn btn-sm" title="å¤åˆ¶å½“å‰è·¯å¾„"
                                    onclick="copyPath('source')"
                                    style="padding:0 4px; background: transparent; border: none; border-radius:4px;">
                                <i class="bi bi-files text-secondary" style="font-size: 0.85rem;"></i>
                            </button>
                            <button type="button" class="btn btn-sm" title="å±•å¼€å›¾ç‰‡"
                                    onclick="openImageGrid(true)"
                                    style="padding:0 4px; background: transparent; border: none; border-radius:4px;">
                                <i class="bi bi-grid-3x3-gap text-info" style="font-size: 0.9rem;"></i>
                            </button>
                        </div>
                    </div>
                    <div id="sourceFileBrowser" class="file-browser" style="height: calc(100% - 50px); padding-bottom: 10px;">
                        <div class="text-center text-muted p-3">
                            <i class="bi bi-server fs-3 mb-2 d-block opacity-50"></i>
                            <p class="mb-0" style="font-size: 0.85rem;">è¯·å…ˆé€‰æ‹©æœåŠ¡å™¨</p>
                        </div>
                    </div>
                </div>

                <div class="resizer" id="verticalResizer"></div>

                <div class="resizable-panel" id="targetPanel" style="width: 50%; height: 100%;">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <h6 style="font-size: 0.9rem; margin-bottom: 0;">
                            <i class="bi bi-folder-check text-success"></i> å³ä¾§æ–‡ä»¶æµè§ˆ
                        </h6>
                        <div class="d-flex align-items-center" style="gap: 10px;">
                            <small id="targetFileCount" style="font-size: 0.75rem; color: #64748b;">å…± 0 é¡¹</small>
                            <small id="targetSelectedInfo" style="font-size: 0.75rem; color: #198754; display: none;"></small>
                            <button class="btn btn-outline-success btn-sm" onclick="refreshTarget()" title="åˆ·æ–°ç›®å½•å†…å®¹" style="font-size: 0.75rem; padding: 2px 6px;">
                                <i class="bi bi-arrow-clockwise"></i> åˆ·æ–°
                            </button>
                            <div class="form-check form-switch" style="font-size: 0.75rem;">
                                <input class="form-check-input" type="checkbox" id="targetShowHidden" onchange="toggleHiddenFiles('target')">
                                <label class="form-check-label" for="targetShowHidden" style="font-size: 0.75rem;">
                                    æ˜¾ç¤ºéšè—æ–‡ä»¶
                                </label>
                            </div>
                        </div>
                    </div>
                    <div id="targetPathNav" class="path-nav" style="display: none; padding: 3px 8px; font-size: 0.8rem; position: relative;" onclick="maybeStartPathInlineEdit(event, false)">
                        <i class="bi bi-geo-alt-fill text-success me-1"></i>
                        <span id="targetPathDisplay">/</span>
                        <div style="position:absolute; right:6px; top:50%; transform: translateY(-50%); display: flex; gap: 2px;">
                            <button type="button" class="btn btn-sm" title="åˆ é™¤é€‰ä¸­é¡¹"
                                    onclick="deleteSelected('target')"
                                    style="padding:0 4px; background: transparent; border: none; border-radius:4px;">
                                <i class="bi bi-trash text-danger" style="font-size: 0.85rem;"></i>
                            </button>
                            <button type="button" class="btn btn-sm" title="å¤åˆ¶å½“å‰è·¯å¾„"
                                    onclick="copyPath('target')"
                                    style="padding:0 4px; background: transparent; border: none; border-radius:4px;">
                                <i class="bi bi-files text-secondary" style="font-size: 0.85rem;"></i>
                            </button>
                            <button type="button" class="btn btn-sm" title="å±•å¼€å›¾ç‰‡"
                                    onclick="openImageGrid(false)"
                                    style="padding:0 4px; background: transparent; border: none; border-radius:4px;">
                                <i class="bi bi-grid-3x3-gap text-success" style="font-size: 0.9rem;"></i>
                            </button>
                        </div>
                    </div>
                    <div id="targetFileBrowser" class="file-browser" style="height: calc(100% - 50px); padding-bottom: 10px;">
                        <div class="text-center text-muted p-3">
                            <i class="bi bi-cloud-upload fs-3 mb-2 d-block opacity-50"></i>
                            <p class="mb-0" style="font-size: 0.85rem;">è¯·å…ˆé€‰æ‹©ç›®æ ‡æœåŠ¡å™¨</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ä¼ è¾“æ§åˆ¶é¢æ¿ -->
        <div class="row flex-shrink-0">
            <div class="col-12">
                <div class="card">
                    <div class="card-body" style="padding: 8px 12px;">
                        <div class="text-center" style="display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap;">
                            <!-- ä¼ è¾“æ¨¡å¼é€‰æ‹©å™¨ï¼ˆåˆ†ç¦»æ ·å¼ï¼‰ -->
                            <input type="radio" class="btn-check" name="transferMode" id="modeCopy" value="copy" checked>
                            <label class="btn btn-outline-primary transfer-mode-btn" for="modeCopy">
                                <i class="bi bi-files"></i> å¤åˆ¶
                            </label>

                            <input type="radio" class="btn-check" name="transferMode" id="modeMove" value="move">
                            <label class="btn btn-outline-primary transfer-mode-btn" for="modeMove">
                                <i class="bi bi-scissors"></i> å‰ªåˆ‡
                            </label>

                            <!-- å¼€å§‹ä¼ è¾“æŒ‰é’® -->
                            <button id="startTransferBtn" class="btn btn-primary me-2" onclick="startTransfer()" style="padding: 6px 16px;">
                                <i class="bi bi-lightning-charge-fill"></i> å¼€å§‹ä¼ è¾“
                            </button>

                            <!-- å–æ¶ˆä¼ è¾“æŒ‰é’® -->
                            <button id="cancelTransferBtn" class="btn btn-danger me-2" onclick="cancelTransfer()" ondblclick="forceCancelTransfer()" style="display: none; padding: 6px 16px;" title="å•å‡»å–æ¶ˆä¼ è¾“ï¼ŒåŒå‡»å¼ºåˆ¶ç»ˆæ­¢">
                                <i class="bi bi-stop-circle-fill"></i> å–æ¶ˆä¼ è¾“
                            </button>

                            <!-- æŸ¥çœ‹æ—¥å¿—æŒ‰é’® -->
                            <button class="btn btn-primary" onclick="showLogModal()" style="padding: 6px 12px;" title="æŸ¥çœ‹ä¼ è¾“æ—¥å¿—">
                                <i class="bi bi-journal-text"></i> æŸ¥çœ‹æ—¥å¿—
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- è¿›åº¦æ˜¾ç¤º -->
        <div class="row flex-shrink-0">
            <div class="col-12">
                <div id="progressContainer" class="progress-container">
                    <div class="card">
                        <div class="card-body">
                            <!-- ä¼ è¾“è·¯å¾„æ˜¾ç¤º -->
                            <div class="transfer-route mb-2 p-2 bg-light rounded" style="height: 40px; display: flex; align-items: center; justify-content: center;">
                                <div id="transferRoute" class="fw-bold text-primary" style="font-size: 14px;">
                                    <i class="bi bi-arrow-right-circle-fill me-1"></i>
                                    å‡†å¤‡ä¼ è¾“...
                                </div>
                            </div>
                            <div class="row g-2">
                                <div class="col-6 col-md-3">
                                    <div class="d-flex align-items-center">
                                        <i class="bi bi-speedometer text-info me-1" style="font-size: 0.85rem;"></i>
                                        <div>
                                            <small class="text-muted" style="font-size: 0.75em;">é€Ÿåº¦</small>
                                            <div id="transferSpeed" class="fw-bold" style="font-size: 0.85rem;">-</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-6 col-md-3">
                                    <div class="d-flex align-items-center">
                                        <i class="bi bi-download text-success me-1" style="font-size: 0.85rem;"></i>
                                        <div>
                                            <small class="text-muted" style="font-size: 0.75em;">å·²ä¼ è¾“</small>
                                            <div id="transferredBytes" class="fw-bold" style="font-size: 0.85rem;">-</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-6 col-md-3">
                                    <div class="d-flex align-items-center">
                                        <i class="bi bi-clock text-warning me-1" style="font-size: 0.85rem;"></i>
                                        <div>
                                            <small class="text-muted" style="font-size: 0.75em;">å·²ç”¨æ—¶é—´</small>
                                            <div id="elapsedTime" class="fw-bold" style="font-size: 0.85rem;">00:00:00</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-6 col-md-3">
                                    <div class="d-flex align-items-center">
                                        <i class="bi bi-info-circle text-primary me-1" style="font-size: 0.85rem;"></i>
                                        <div>
                                            <small class="text-muted" style="font-size: 0.75em;">çŠ¶æ€</small>
                                            <div id="transferStatus" class="fw-bold" style="font-size: 0.85rem;">å‡†å¤‡ä¸­</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>




    </div>

    <!-- æ–‡ä»¶åŒºå³é”®èœå• -->
    <div id="fileContextMenu" class="file-context-menu">
        <div class="menu-item" data-action="rename">
            <i class="bi bi-pencil-square text-warning"></i>
            <span>é‡å‘½å</span>
        </div>
        <div class="menu-item" data-action="new-file">
            <i class="bi bi-file-earmark-plus text-primary"></i>
            <span>æ–°å»ºæ–‡ä»¶</span>
        </div>
        <div class="menu-item" data-action="new-folder">
            <i class="bi bi-folder-plus text-success"></i>
            <span>æ–°å»ºæ–‡ä»¶å¤¹</span>
        </div>
        <div class="menu-item" data-action="run">
            <i class="bi bi-play-fill text-primary"></i>
            <span>è¿è¡Œ</span>
        </div>
        <div class="menu-item" data-action="compare">
            <i class="bi bi-shuffle text-info"></i>
            <span>å¯¹æ¯”</span>
        </div>
        <div class="menu-item" data-action="size">
            <i class="bi bi-hdd-network text-info"></i>
            <span>è®¡ç®—å¤§å°</span>
        </div>
        <div class="menu-item" data-action="compress">
            <i class="bi bi-archive text-primary"></i>
            <span>å‹ç¼©</span>
        </div>
        <div class="menu-item" data-action="extract">
            <i class="bi bi-box-arrow-down text-success"></i>
            <span>è§£å‹</span>
        </div>
        <div class="menu-item" data-action="download-windows">
            <i class="bi bi-windows text-primary"></i>
            <span>ä¸‹è½½åˆ°Windows</span>
        </div>
    </div>

    

    <!-- ä¸‹è½½åˆ°Windowsï¼šé€‰æ‹©ç›®æ ‡ç›®å½• -->
    <div class="modal" id="downloadWindowsModal" tabindex="-1" aria-labelledby="downloadWindowsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-scrollable download-win-dialog">
            <div class="modal-content download-win-modal">
                <div class="modal-header">
                    <h5 class="modal-title" id="downloadWindowsModalLabel">
                        <i class="bi bi-windows text-primary"></i> ä¸‹è½½åˆ°Windows
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="d-flex align-items-center gap-2 mb-2 download-win-drive-row">
                        <label class="form-label mb-0" for="downloadWindowsDriveSelect">ç£ç›˜</label>
                        <select id="downloadWindowsDriveSelect" class="form-select form-select-sm download-win-drive"></select>
                    </div>

                    <div id="downloadWindowsDirList" class="list-group download-win-list"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary btn-sm" onclick="confirmDownloadToWindows()">
                        <i class="bi bi-download me-1"></i> ä¸‹è½½åˆ°æ­¤ç›®å½•
                    </button>
                </div>
            </div>
        </div>
    </div>
<!-- ä¼ è¾“æ—¥å¿—æ¨¡æ€çª—å£ -->
    <div class="modal fade" id="logModal" tabindex="-1" aria-labelledby="logModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="logModalLabel">
                        <i class="bi bi-journal-text text-secondary"></i> ä¼ è¾“æ—¥å¿—
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
            <div class="modal-body">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <small class="text-muted">å®æ—¶æ˜¾ç¤ºä¼ è¾“è¿‡ç¨‹ä¸­çš„è¯¦ç»†ä¿¡æ¯</small>
                        <div class="d-flex align-items-center" style="gap: 6px; flex-wrap: wrap;">
                            <div class="input-group input-group-sm" style="width: 240px;">
                                <input id="runInputBox" type="text" class="form-control" placeholder="å‘è„šæœ¬è¾“å…¥å†…å®¹ï¼Œå›è½¦å‘é€"
                                       onkeydown="if(event.key === 'Enter'){ event.preventDefault(); sendRunInput(); }">
                                <button id="runSendBtn" class="btn btn-outline-primary" type="button" onclick="sendRunInput()">å‘é€</button>
                            </div>
                            <button id="runStopBtn" class="btn btn-outline-primary btn-sm" onclick="cancelCurrentRun()" style="font-size: 0.75rem;">
                                <i class="bi bi-stop-circle"></i> åœæ­¢è„šæœ¬
                            </button>
                            <button class="btn btn-outline-secondary btn-sm" onclick="clearLog()" style="font-size: 0.75rem;">
                                <i class="bi bi-trash3"></i> æ¸…ç©ºæ—¥å¿—
                            </button>
                        </div>
                    </div>
                    <div id="logContainer" class="log-container">
                        <div id="logContent" class="log-content">
                            <!-- æ—¥å¿—å†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">å…³é—­</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script>
        // WebSocketè¿æ¥
        const socket = io();
        let currentTransferId = null;
        let selectedSourceFiles = [];
        let selectedTargetFiles = [];
        let currentTransferDirection = 'ltr';
        let currentTransferMode = 'copy'; // 'copy' æˆ– 'move'
        let currentSourcePath = '';
        let currentTargetPath = '';

        // Windows ç£ç›˜ç¼“å­˜ï¼ˆåˆ†åˆ«ç”¨äºæº/ç›®æ ‡ï¼‰ï¼Œä¾›è·¯å¾„å¯¼èˆªä¸‹æ‹‰ä½¿ç”¨
        let windowsDrivesSource = [];
        let windowsDrivesTarget = [];

        // ç›®å½•æµè§ˆåˆ†é¡µçŠ¶æ€ï¼Œé¿å…ä¸€æ¬¡æ€§æ¸²æŸ“è¿‡å¤šæ–‡ä»¶å¯¼è‡´å¡é¡¿
        const BROWSE_PAGE_SIZE = 400;
        const BROWSE_PAGE_SIZE_MAX = 2000;
        const browseState = {
            source: { path: null, offset: 0, total: 0, hasMore: false, loading: false, controller: null, loadedCount: 0, requestToken: '', fullItems: [], fullOffset: 0, fullHasMore: false, loadingAll: false },
            target: { path: null, offset: 0, total: 0, hasMore: false, loading: false, controller: null, loadedCount: 0, requestToken: '', fullItems: [], fullOffset: 0, fullHasMore: false, loadingAll: false }
        };

        // Shift è¿é€‰é”šç‚¹
        const lastSelectedIndex = { source: null, target: null };
        let lastActivePanel = 'source';


        // æ–‡ä»¶ä¼ è¾“å‰ªè´´æ¿ï¼ˆCtrl+C / Ctrl+X / Ctrl+Vï¼‰
        // ç›®æ ‡ï¼šå¿«æ·é”®è§¦å‘çš„ä¼ è¾“ä¸â€œæ‰‹åŠ¨é€‰æ‹© + ç‚¹å‡»å¼€å§‹ä¼ è¾“â€èµ°åŒä¸€å¥—åç«¯æµç¨‹ä¸å‚æ•°ï¼Œé€Ÿåº¦ä¸€è‡´
        let transferClipboard = null; // { mode: 'copy'|'move', sourcePanel: 'source'|'target', sourceServer: string, files: Array<{path,name,is_directory}>, ts: number }
        let transferRefreshOverride = null; // { refreshSource: boolean, refreshTarget: boolean } | null

        function _cloneTransferFiles(files) {
            return (files || []).map(f => ({
                path: f.path,
                name: f.name,
                is_directory: !!f.is_directory
            }));
        }

        function _isEditableElement(el) {
            if (!el) return false;
            const tag = (el.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
            return !!el.isContentEditable;
        }

        function _hasTextSelection() {
            try {
                const sel = window.getSelection && window.getSelection();
                return !!(sel && String(sel.toString() || '').trim());
            } catch (_) {
                return false;
            }
        }

        function _getPanelServer(panel) {
            const id = panel === 'target' ? 'targetServer' : 'sourceServer';
            const el = document.getElementById(id);
            return el ? (el.value || '') : '';
        }

        function _getPanelPath(panel) {
            return panel === 'target' ? currentTargetPath : currentSourcePath;
        }

        function startTransferWithParams(sourceServer, targetServer, targetPath, sourceFiles, mode, direction, refreshOverride = null) {
            if (isTransferring) {
                addLogWarning('âš ï¸ å·²æœ‰ä¼ è¾“ä»»åŠ¡åœ¨è¿›è¡Œä¸­');
                return false;
            }

            const files = _cloneTransferFiles(sourceFiles || []);
            if (!files.length) {
                addLogWarning('âš ï¸ è¯·é€‰æ‹©è¦ä¼ è¾“çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                return false;
            }

            const finalMode = (mode === 'move') ? 'move' : 'copy';
            currentTransferMode = finalMode;
            currentTransferDirection = direction || currentTransferDirection || 'ltr';

            const fastSSH = true;
            const parallelTransfer = true;

            // å‰ªåˆ‡æ¨¡å¼å¼¹çª—æé†’ï¼ˆä¸ startTransfer ä¿æŒä¸€è‡´ï¼‰
            if (finalMode === 'move') {
                const ok = confirm('å½“å‰é€‰æ‹©çš„æ˜¯ã€Œå‰ªåˆ‡ã€æ¨¡å¼ï¼Œæºæ–‡ä»¶å°†è¢«åˆ é™¤ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ');
                if (!ok) {
                    return false;
                }
            }

            // æœåŠ¡å™¨ä¸è·¯å¾„æ ¡éªŒ
            if (!sourceServer || !targetServer || !targetPath) {
                addLogWarning('âš ï¸ è¯·é€‰æ‹©æºæœåŠ¡å™¨ã€ç›®æ ‡æœåŠ¡å™¨å’Œç›®æ ‡è·¯å¾„');
                alert('è¯·é€‰æ‹©æºæœåŠ¡å™¨ã€ç›®æ ‡æœåŠ¡å™¨å’Œç›®æ ‡è·¯å¾„');
                return false;
            }

            // åŒæœåŠ¡å™¨è·¯å¾„å†²çªæ ¡éªŒ
            if (sourceServer === targetServer) {
                const hasConflict = files.some(file =>
                    file.path === targetPath || targetPath.startsWith(file.path + '/')
                );
                if (hasConflict) {
                    addLogWarning('âš ï¸ æºè·¯å¾„å’Œç›®æ ‡è·¯å¾„ä¸èƒ½ç›¸åŒæˆ–å­˜åœ¨åŒ…å«å…³ç³»');
                    alert('æºè·¯å¾„å’Œç›®æ ‡è·¯å¾„ä¸èƒ½ç›¸åŒæˆ–å­˜åœ¨åŒ…å«å…³ç³»');
                    return false;
                }
            }

            // åŒä¾§ç²˜è´´æ—¶ï¼Œä»…åˆ·æ–°å½“å‰ä¾§ï¼Œé¿å…åˆ·æ–°å¦ä¸€ä¾§é€ æˆå¹²æ‰°
            transferRefreshOverride = refreshOverride;

            // è®¾ç½®ä¼ è¾“çŠ¶æ€
            isTransferring = true;

            // æ˜¾ç¤ºè¿›åº¦é¢æ¿
            document.getElementById('progressContainer').style.display = 'block';
            const startBtn = document.getElementById('startTransferBtn');
            if (startBtn) startBtn.style.display = 'none';
            document.getElementById('cancelTransferBtn').style.display = 'inline-block';

            const fileNames = files.map(f => f.name).join(', ');
            addLogInfo(`ğŸ“¤ æº: ${sourceServer} (${files.length}é¡¹)`);
            addLogInfo(`ğŸ“¥ ç›®æ ‡: ${targetServer}:${targetPath}`);
            addLogInfo(`ğŸ“‹ æ–‡ä»¶: ${fileNames.length > 50 ? fileNames.substring(0, 50) + '...' : fileNames}`);

            // å‘é€ä¼ è¾“è¯·æ±‚
            socket.emit('start_transfer', {
                source_server: sourceServer,
                source_files: files,
                target_server: targetServer,
                target_path: targetPath,
                mode: finalMode,
                fast_ssh: fastSSH,
                parallel_transfer: parallelTransfer
            });

            return true;
        }

        function setTransferClipboardFromSelection(mode) {
            if (isTransferring) {
                addLogWarning('âš ï¸ ä¼ è¾“è¿›è¡Œä¸­ï¼Œæš‚ä¸æ”¯æŒå¤åˆ¶/å‰ªåˆ‡');
                return;
            }

            const leftSelected = selectedSourceFiles.length > 0;
            const rightSelected = selectedTargetFiles.length > 0;

            // ä¸ startTransfer ä¸€è‡´ï¼šåªå…è®¸ä¸€ä¾§é€‰ä¸­ä»¥ç¡®å®šæº
            if (leftSelected && rightSelected) {
                addLogWarning('âš ï¸ å·¦å³ä¸¤ä¾§åŒæ—¶é€‰æ‹©äº†é¡¹ç›®ï¼Œè¯·åªåœ¨ä¸€ä¾§é€‰æ‹©');
                alert('å·¦å³ä¸¤ä¾§åŒæ—¶é€‰æ‹©äº†é¡¹ç›®ï¼Œè¯·åªåœ¨ä¸€ä¾§é€‰æ‹©');
                return;
            }
            if (!leftSelected && !rightSelected) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©è¦å¤åˆ¶/å‰ªåˆ‡çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                return;
            }

            const sourcePanel = leftSelected ? 'source' : 'target';
            const sourceServer = _getPanelServer(sourcePanel);
            if (!sourceServer) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æºæœåŠ¡å™¨');
                return;
            }

            const sourceFiles = _cloneTransferFiles(leftSelected ? selectedSourceFiles : selectedTargetFiles);
            transferClipboard = {
                mode: mode === 'move' ? 'move' : 'copy',
                sourcePanel,
                sourceServer,
                files: sourceFiles,
                ts: Date.now()
            };

            const opText = transferClipboard.mode === 'move' ? 'å‰ªåˆ‡' : 'å¤åˆ¶';
            addLogSuccess(`ğŸ“‹ å·²${opText} ${sourceFiles.length} é¡¹ï¼ˆCtrl+V ç²˜è´´åˆ°å½“å‰æ¿€æ´»ä¾§ï¼‰`);
        }

        function pasteTransferClipboard() {
            if (!transferClipboard || !transferClipboard.files || transferClipboard.files.length === 0) {
                addLogWarning('âš ï¸ å‰ªè´´æ¿ä¸ºç©ºï¼šè¯·å…ˆ Ctrl+C æˆ– Ctrl+X é€‰æ‹©æ–‡ä»¶');
                return;
            }
            if (isTransferring) {
                addLogWarning('âš ï¸ å·²æœ‰ä¼ è¾“ä»»åŠ¡åœ¨è¿›è¡Œä¸­');
                return;
            }

            // æºé¢æ¿æœåŠ¡å™¨è¢«åˆ‡æ¢æ—¶ï¼Œå‰ªè´´æ¿å†…å®¹å¯èƒ½ä¸å†æœ‰æ•ˆï¼Œé¿å…è¯¯ä¼ 
            const currentSourceServer = _getPanelServer(transferClipboard.sourcePanel);
            if (currentSourceServer && transferClipboard.sourceServer && currentSourceServer !== transferClipboard.sourceServer) {
                addLogWarning(`âš ï¸ æºé¢æ¿æœåŠ¡å™¨å·²ä» ${transferClipboard.sourceServer} åˆ‡æ¢ä¸º ${currentSourceServer}ï¼Œè¯·é‡æ–° Ctrl+C/Ctrl+X é€‰æ‹©åå†ç²˜è´´`);
                return;
            }

            // ç²˜è´´åˆ°â€œå½“å‰æ¿€æ´»é¢æ¿â€ï¼ˆæ”¯æŒåŒä¾§ä¸è·¨ä¾§ï¼‰
            const destPanel = (lastActivePanel === 'target') ? 'target' : 'source';
            const targetServer = _getPanelServer(destPanel);
            const targetPath = _getPanelPath(destPanel);

            if (!targetServer) {
                addLogWarning(destPanel === 'source' ? 'âš ï¸ è¯·å…ˆé€‰æ‹©æºæœåŠ¡å™¨' : 'âš ï¸ è¯·å…ˆé€‰æ‹©ç›®æ ‡æœåŠ¡å™¨');
                return;
            }
            if (!targetPath) {
                addLogWarning('âš ï¸ è¯·å…ˆæµè§ˆåˆ°ç›®æ ‡ç›®å½•');
                return;
            }

            const mode = transferClipboard.mode === 'move' ? 'move' : 'copy';
            const modeEl = document.getElementById(mode === 'move' ? 'modeMove' : 'modeCopy');
            if (modeEl) modeEl.checked = true;

            // æ–¹å‘ç”¨äºå…¼å®¹ç°æœ‰å®Œæˆååˆ·æ–°é€»è¾‘ï¼›åŒä¾§ç²˜è´´æ—¶é€šè¿‡ refreshOverride æ§åˆ¶åªåˆ·æ–°å½“å‰ä¾§
            let direction = (destPanel === 'target') ? 'ltr' : 'rtl';
            if (transferClipboard.sourcePanel === 'source' && destPanel === 'target') direction = 'ltr';
            if (transferClipboard.sourcePanel === 'target' && destPanel === 'source') direction = 'rtl';

            let refreshOverride = null;
            if (destPanel === transferClipboard.sourcePanel) {
                refreshOverride = {
                    refreshSource: destPanel === 'source',
                    refreshTarget: destPanel === 'target'
                };
            }

            const started = startTransferWithParams(
                transferClipboard.sourceServer,
                targetServer,
                targetPath,
                transferClipboard.files,
                mode,
                direction,
                refreshOverride
            );

            // å‰ªåˆ‡è¯­ä¹‰ï¼šé€šå¸¸åªç²˜è´´ä¸€æ¬¡ï¼›è‹¥ç”¨æˆ·åœ¨ç¡®è®¤å¼¹çª—ä¸­å–æ¶ˆï¼Œåˆ™ä¸æ¸…ç©ºå‰ªè´´æ¿
            if (started && mode === 'move') {
                transferClipboard = null;
            }
        }

        function setupTransferClipboardHotkeys() {
            document.addEventListener('keydown', (event) => {
                const key = (event.key || '').toLowerCase();
                const isMod = event.ctrlKey || event.metaKey;
                if (!isMod) return;
                if (event.altKey || event.shiftKey) return;

                // è¾“å…¥æ¡†/ç¼–è¾‘å™¨å†…ä¿æŒé»˜è®¤å¤åˆ¶ç²˜è´´è¡Œä¸º
                if (_isEditableElement(event.target)) return;

                // è‹¥ç”¨æˆ·é€‰ä¸­äº†æ–‡æœ¬ï¼ˆä¾‹å¦‚å¤åˆ¶æ—¥å¿—ï¼‰ï¼ŒCtrl+C/Ctrl+X äº¤ç»™æµè§ˆå™¨é»˜è®¤è¡Œä¸º
                if ((key === 'c' || key === 'x') && _hasTextSelection()) return;

                if (key === 'c') {
                    event.preventDefault();
                    setTransferClipboardFromSelection('copy');
                } else if (key === 'x') {
                    event.preventDefault();
                    setTransferClipboardFromSelection('move');
                } else if (key === 'v') {
                    event.preventDefault();
                    pasteTransferClipboard();
                }
            }, { capture: true });
        }

        setupTransferClipboardHotkeys();

        // å³é”®ï¼šä¸‹è½½åˆ°Windowsï¼ˆç­‰ä»·äºæ‰‹åŠ¨é€‰æ‹© + ä¼ è¾“åˆ°Windowsï¼‰
        let downloadWindowsContext = null; // { sourcePanel, destPanel, sourceServer, files }
        const downloadWinPicker = { server: '', path: '', selectedPath: '', drives: [] };

        function _getDownloadWinAnchor() {
            const anchor = (typeof window !== 'undefined' && window.downloadWinAnchor) ? window.downloadWinAnchor : null;
            let x = anchor ? Number(anchor.x) : NaN;
            let y = anchor ? Number(anchor.y) : NaN;

            if (!Number.isFinite(x) || !Number.isFinite(y)) {
                x = window.innerWidth / 2;
                y = window.innerHeight / 4;
            }

            return { x, y };
        }

        function positionDownloadWindowsModal() {
            const modalEl = document.getElementById('downloadWindowsModal');
            const dialog = modalEl ? modalEl.querySelector('.download-win-dialog') : null;
            if (!dialog) return;

            const anchor = _getDownloadWinAnchor();
            const rect = dialog.getBoundingClientRect();
            const menuWidth = rect.width || 420;
            const menuHeight = rect.height || 520;
            const padding = 8;
            let left = anchor.x;
            let top = anchor.y;

            if (left + menuWidth > window.innerWidth - padding) {
                left = window.innerWidth - menuWidth - padding;
            }
            if (top + menuHeight > window.innerHeight - padding) {
                top = window.innerHeight - menuHeight - padding;
            }

            dialog.style.left = `${Math.max(padding, left)}px`;
            dialog.style.top = `${Math.max(padding, top)}px`;
        }

        function positionDownloadWindowsModal() {
            const modalEl = document.getElementById('downloadWindowsModal');
            const dialog = modalEl ? modalEl.querySelector('.download-win-dialog') : null;
            if (!dialog) return;

            const anchor = _getDownloadWinAnchor();
            const rect = dialog.getBoundingClientRect();
            const width = rect.width || 420;
            const height = rect.height || 520;
            const padding = 8;
            const gap = 10;

            let left = anchor.x;
            let top = anchor.y;

            if (anchor.rect) {
                left = anchor.rect.right + gap;
                top = anchor.rect.top;
            }

            const maxLeft = window.innerWidth - width - padding;
            const maxTop = window.innerHeight - height - padding;

            if (left > maxLeft) {
                const altLeft = anchor.rect ? (anchor.rect.left - width - gap) : maxLeft;
                left = (Number.isFinite(altLeft) && altLeft >= padding) ? altLeft : maxLeft;
            }

            if (top > maxTop) {
                const altTop = anchor.rect ? (anchor.rect.bottom - height) : maxTop;
                top = Math.max(padding, altTop);
            }

            if (left < padding) left = padding;
            if (top < padding) top = padding;

            dialog.style.left = `${left}px`;
            dialog.style.top = `${top}px`;
        }

        function positionDownloadWindowsModal() {
            const modalEl = document.getElementById('downloadWindowsModal');
            const dialog = modalEl ? modalEl.querySelector('.download-win-dialog') : null;
            if (!dialog) return;

            const anchor = _getDownloadWinAnchor();
            const rect = dialog.getBoundingClientRect();
            const width = rect.width || 420;
            const height = rect.height || 520;
            const padding = 8;

            let left = anchor.x;
            let top = anchor.y;

            if (left + width > window.innerWidth - padding) {
                left = window.innerWidth - width - padding;
            }
            if (top + height > window.innerHeight - padding) {
                top = window.innerHeight - height - padding;
            }

            if (left < padding) left = padding;
            if (top < padding) top = padding;

            dialog.style.left = `${left}px`;
            dialog.style.top = `${top}px`;
        }


        function _listWindowsServers() {
            try {
                return Object.entries(SERVERS_DATA || {})
                    .filter(([ip, meta]) => meta && meta.os_type === 'windows')
                    .map(([ip, meta]) => ({ ip, meta }));
            } catch (_) {
                return [];
            }
        }

        function _suggestWindowsServer(windowsServers) {
            const list = Array.isArray(windowsServers) ? windowsServers : _listWindowsServers();
            if (!list.length) return '';

            const clientIp = (typeof window !== 'undefined' && window.CLIENT_IPV4) ? window.CLIENT_IPV4 : null;
            if (clientIp) {
                const hit = list.find(s => s.ip === clientIp);
                if (hit) return hit.ip;
            }

            const targetServer = (document.getElementById('targetServer') || {}).value || '';
            if (targetServer && isWindowsServer(targetServer)) return targetServer;

            const sourceServer = (document.getElementById('sourceServer') || {}).value || '';
            if (sourceServer && isWindowsServer(sourceServer)) return sourceServer;

            return list[0].ip;
        }

        function _normalizeSlashes(p) {
            return String(p || '').replace(/\\/g, '/');
        }

        function _normalizeDriveLetter(letter) {
            if (!letter) return '';
            const up = String(letter).trim().toUpperCase();
            return up.endsWith(':') ? up : `${up}:`;
        }

        function _driveRoot(letter) {
            const d = _normalizeDriveLetter(letter);
            return d ? `${d}/` : '';
        }

        function _normalizeWinPath(p) {
            let path0 = _normalizeSlashes(p).trim();
            if (!path0) return '';

            const m = path0.match(/^([a-zA-Z]:)(?:\/(.*))?$/);
            if (m) {
                const drive = String(m[1]).toUpperCase();
                const rest = m[2] ? String(m[2]) : '';
                path0 = rest ? `${drive}/${rest}` : `${drive}/`;
            }

            if (/^[A-Z]:$/.test(path0)) {
                path0 = `${path0}/`;
            }

            if (path0.length > 3 && path0.endsWith('/')) {
                path0 = path0.slice(0, -1);
            }

            return path0;
        }

        function _getWinParent(p) {
            const path0 = _normalizeWinPath(p);
            if (!path0) return '';
            if (/^[A-Z]:\/$/.test(path0)) return path0;
            const idx = path0.lastIndexOf('/');
            if (idx <= 2) return path0.slice(0, 3);
            return path0.slice(0, idx);
        }

        function _renderWindowsServerOptions(selectEl, list) {
            if (!selectEl) return;
            selectEl.innerHTML = '';
            list.forEach(({ ip, meta }) => {
                const opt = document.createElement('option');
                opt.value = ip;
                const name = (meta && meta.name) ? meta.name : ip;
                opt.textContent = `${name} (${ip})`;
                selectEl.appendChild(opt);
            });
        }

        async function downloadWinPickerLoadDrives(serverIP) {
            const driveSelect = document.getElementById('downloadWindowsDriveSelect');
            if (!driveSelect) return;

            driveSelect.innerHTML = '';
            driveSelect.disabled = true;
            downloadWinPicker.drives = [];

            if (!serverIP) {
                driveSelect.innerHTML = '<option value="">(æœªé€‰æ‹©)</option>';
                return;
            }

            try {
                const resp = await fetch(`/api/windows_drives/${serverIP}`, { cache: 'no-cache' });
                const data = await resp.json();

                if (data.success && Array.isArray(data.drives) && data.drives.length) {
                    downloadWinPicker.drives = data.drives;
                    data.drives.forEach(d => {
                        const root = _driveRoot(d.letter);
                        if (!root) return;
                        const opt = document.createElement('option');
                        opt.value = root;
                        opt.textContent = root;
                        driveSelect.appendChild(opt);
                    });
                    driveSelect.disabled = false;

                    const cur = _normalizeWinPath(downloadWinPicker.path || '');
                    const curDrive = _normalizeDriveLetter((cur.split('/')[0] || ''));
                    const prefer = data.drives.find(dd => _normalizeDriveLetter(dd.letter) === curDrive)
                        || data.drives.find(dd => _normalizeDriveLetter(dd.letter) === 'C:')
                        || data.drives[0];
                    if (prefer) {
                        driveSelect.value = _driveRoot(prefer.letter);
                    }
                } else {
                    driveSelect.innerHTML = '<option value="">(æ— ç£ç›˜ä¿¡æ¯)</option>';
                }
            } catch (_) {
                driveSelect.innerHTML = '<option value="">(åŠ è½½å¤±è´¥)</option>';
            }
        }

        function _updateDownloadWinDirActive() {
            const listEl = document.getElementById('downloadWindowsDirList');
            if (!listEl) return;
            const selected = downloadWinPicker.selectedPath || '';
            Array.from(listEl.querySelectorAll('.list-group-item')).forEach(el => {
                if (selected && el.dataset.path === selected) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            });
        }

        function downloadWinPickerSelectPath(p) {
            const path0 = _normalizeWinPath(p);
            if (!path0) return;
            downloadWinPicker.selectedPath = path0;
            const input = document.getElementById('downloadWindowsPathInput');
            if (input) input.value = path0;
            _updateDownloadWinDirActive();
        }

        async function downloadWinPickerLoadDirs() {
            const listEl = document.getElementById('downloadWindowsDirList');
            if (!listEl) return;

            const serverIP = downloadWinPicker.server;
            const p = downloadWinPicker.path;
            if (!serverIP) {
                listEl.innerHTML = '<div class="list-group-item text-muted">æœªæ‰¾åˆ°WindowsæœåŠ¡å™¨</div>';
                return;
            }
            if (!p) {
                listEl.innerHTML = '<div class="list-group-item text-muted">è¯·é€‰æ‹©ç£ç›˜</div>';
                return;
            }

            listEl.innerHTML = '<div class="list-group-item text-muted">åŠ è½½ä¸­...</div>';

            try {
                const params = new URLSearchParams({
                    path: p,
                    show_hidden: 'false',
                    offset: '0',
                    limit: '2000'
                });
                const resp = await fetch(`/api/browse/${serverIP}?${params.toString()}`, { cache: 'no-cache' });
                const data = await resp.json();
                if (!data.success) {
                    listEl.innerHTML = `<div class="list-group-item text-danger">æµè§ˆå¤±è´¥: ${data.error || 'æœªçŸ¥é”™è¯¯'}</div>`;
                    return;
                }

                const dirs = (data.files || []).filter(f => f && f.is_directory);
                dirs.sort((a, b) => String(a.name || '').localeCompare(String(b.name || ''), 'zh-CN', { numeric: true, sensitivity: 'base' }));

                listEl.innerHTML = '';

                const current = _normalizeWinPath(p);
                const parent = _getWinParent(current);
                if (parent && parent !== current) {
                    const upBtn = document.createElement('button');
                    upBtn.type = 'button';
                    upBtn.className = 'list-group-item list-group-item-action d-flex align-items-center';
                    upBtn.dataset.path = parent;

                    const icon = document.createElement('i');
                    icon.className = 'bi bi-arrow-90deg-up text-secondary me-2';
                    const name = document.createElement('span');
                    name.textContent = 'ä¸Šä¸€çº§';

                    upBtn.appendChild(icon);
                    upBtn.appendChild(name);

                    upBtn.addEventListener('click', () => downloadWinPickerEnterPath(upBtn.dataset.path));
                    upBtn.addEventListener('dblclick', () => downloadWinPickerEnterPath(upBtn.dataset.path));

                    listEl.appendChild(upBtn);
                }

                if (!dirs.length) {
                    const empty = document.createElement('div');
                    empty.className = 'list-group-item text-muted';
                    empty.textContent = 'ï¼ˆæ­¤ç›®å½•ä¸‹æ²¡æœ‰æ–‡ä»¶å¤¹ï¼‰';
                    listEl.appendChild(empty);
                    return;
                }

                dirs.forEach(d => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'list-group-item list-group-item-action d-flex align-items-center';
                    btn.dataset.path = d.path || '';

                    const icon = document.createElement('i');
                    icon.className = 'bi bi-folder-fill text-warning me-2';
                    const name = document.createElement('span');
                    name.textContent = d.name || d.path || '';

                    btn.appendChild(icon);
                    btn.appendChild(name);

                    btn.addEventListener('click', () => downloadWinPickerSelectPath(btn.dataset.path));
                    btn.addEventListener('dblclick', () => downloadWinPickerEnterPath(btn.dataset.path));

                    listEl.appendChild(btn);
                });

                _updateDownloadWinDirActive();
                positionDownloadWindowsModal();
            } catch (e) {
                listEl.innerHTML = `<div class="list-group-item text-danger">æµè§ˆå¤±è´¥: ${String(e)}</div>`;
            }
        }

        async function downloadWinPickerEnterPath(p) {
            const serverIP = downloadWinPicker.server;
            if (!serverIP) return;

            const path0 = _normalizeWinPath(p);
            if (!path0) return;

            downloadWinPicker.path = path0;
            downloadWinPicker.selectedPath = path0;

            const input = document.getElementById('downloadWindowsPathInput');
            if (input) input.value = path0;

            const driveSelect = document.getElementById('downloadWindowsDriveSelect');
            if (driveSelect && !driveSelect.disabled) {
                const drive = _normalizeDriveLetter((path0.split('/')[0] || ''));
                const want = drive ? `${drive}/` : '';
                if (want) driveSelect.value = want;
            }

            await downloadWinPickerLoadDirs();
        }

        function downloadWinPickerRefresh() {
            downloadWinPickerLoadDirs();
        }

        function downloadWinPickerGoUp() {
            const parent = _getWinParent(downloadWinPicker.path || '');
            if (parent) downloadWinPickerEnterPath(parent);
        }

        function downloadWinPickerNavigateToInput() {
            const input = document.getElementById('downloadWindowsPathInput');
            const p = input ? (input.value || '').trim() : '';
            if (!p) return;
            downloadWinPickerEnterPath(p);
        }

        async function downloadWinPickerSetServer(serverIP) {
            if (!serverIP) return;

            downloadWinPicker.server = serverIP;

            const isDestSource = downloadWindowsContext ? (downloadWindowsContext.destPanel === 'source') : false;
            const remembered = getDefaultPathWithRemember(serverIP, isDestSource);
            const fallback = (SERVERS_DATA && SERVERS_DATA[serverIP] && SERVERS_DATA[serverIP].default_path) ? SERVERS_DATA[serverIP].default_path : 'C:/';

            const p = _normalizeWinPath(remembered || fallback);
            downloadWinPicker.path = p;
            downloadWinPicker.selectedPath = p;

            const input = document.getElementById('downloadWindowsPathInput');
            if (input) input.value = p;

            await Promise.all([
                downloadWinPickerLoadDrives(serverIP),
                downloadWinPickerLoadDirs()
            ]);
        }

        async function openDownloadToWindowsModal() {
            if (isTransferring) {
                addLogWarning('âš ï¸ å·²æœ‰ä¼ è¾“ä»»åŠ¡åœ¨è¿›è¡Œä¸­');
                return;
            }

            const leftSelected = selectedSourceFiles.length > 0;
            const rightSelected = selectedTargetFiles.length > 0;

            if (leftSelected && rightSelected) {
                addLogWarning('âš ï¸ å·¦å³ä¸¤ä¾§åŒæ—¶é€‰æ‹©äº†é¡¹ç›®ï¼Œè¯·åªåœ¨ä¸€ä¾§é€‰æ‹©');
                alert('å·¦å³ä¸¤ä¾§åŒæ—¶é€‰æ‹©äº†é¡¹ç›®ï¼Œè¯·åªåœ¨ä¸€ä¾§é€‰æ‹©');
                return;
            }
            if (!leftSelected && !rightSelected) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©è¦ä¸‹è½½çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                return;
            }

            const sourcePanel = leftSelected ? 'source' : 'target';
            const destPanel = leftSelected ? 'target' : 'source';
            const sourceServer = _getPanelServer(sourcePanel);
            if (!sourceServer) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æºæœåŠ¡å™¨');
                return;
            }

            const files = _cloneTransferFiles(leftSelected ? selectedSourceFiles : selectedTargetFiles);
            if (!files.length) {
                addLogWarning('âš ï¸ è¯·é€‰æ‹©è¦ä¸‹è½½çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                return;
            }

            const windowsServers = _listWindowsServers();
            if (!windowsServers.length) {
                addLogWarning('âš ï¸ æœªé…ç½®WindowsæœåŠ¡å™¨ï¼Œæ— æ³•ä¸‹è½½åˆ°Windows');
                alert('æœªé…ç½®WindowsæœåŠ¡å™¨ï¼Œæ— æ³•ä¸‹è½½åˆ°Windows');
                return;
            }

            downloadWindowsContext = { sourcePanel, destPanel, sourceServer, files };

            const suggested = _suggestWindowsServer(windowsServers);
            if (!suggested) {
                addLogWarning('âš ï¸ æœªæ‰¾åˆ°WindowsæœåŠ¡å™¨');
                alert('æœªæ‰¾åˆ°WindowsæœåŠ¡å™¨');
                return;
            }

            const listEl = document.getElementById('downloadWindowsDirList');
            if (listEl) listEl.innerHTML = '<div class="list-group-item text-muted">åŠ è½½ä¸­...</div>';

            const driveSelect = document.getElementById('downloadWindowsDriveSelect');
            if (driveSelect) {
                driveSelect.innerHTML = '<option value="">åŠ è½½ä¸­...</option>';
                driveSelect.disabled = true;
                driveSelect.onchange = () => {
                    const v = driveSelect.value || '';
                    if (v) downloadWinPickerEnterPath(v);
                };
            }

            const modalEl = document.getElementById('downloadWindowsModal');
            if (modalEl && typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                const inst = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true });
                inst.show();
                requestAnimationFrame(() => positionDownloadWindowsModal());
            }

            downloadWinPickerSetServer(suggested)
                .then(() => positionDownloadWindowsModal())
                .catch(() => {});
        }

        function confirmDownloadToWindows() {
            if (!downloadWindowsContext) {
                addLogWarning('âš ï¸ ä¸‹è½½ä¸Šä¸‹æ–‡ä¸¢å¤±ï¼Œè¯·é‡æ–°å³é”®é€‰æ‹©');
                return;
            }

            const winServer = downloadWinPicker.server || '';
            if (!winServer) {
                addLogWarning('âš ï¸ æœªæ‰¾åˆ°WindowsæœåŠ¡å™¨');
                return;
            }

            const targetPathRaw = (downloadWinPicker.selectedPath || downloadWinPicker.path || '').trim();
            const targetPath = _normalizeWinPath(targetPathRaw);
            if (!targetPath) {
                addLogWarning('âš ï¸ è¯·é€‰æ‹©ç›®æ ‡ç›®å½•');
                return;
            }

            // åˆ‡æ¢ç›®æ ‡ä¾§ä¸º Windows æœåŠ¡å™¨ä¸ç›®æ ‡è·¯å¾„ï¼ˆè®©æ•ˆæœä¸æ‰‹åŠ¨é€‰æ‹©ç›®æ ‡ä¾§ä¸€è‡´ï¼‰
            const destPanel = downloadWindowsContext.destPanel;
            const isDestSource = destPanel === 'source';
            updateRememberedCache(destPanel, winServer, targetPath);

            const destSelect = document.getElementById(isDestSource ? 'sourceServer' : 'targetServer');
            if (destSelect) {
                destSelect.value = winServer;
                destSelect.dispatchEvent(new Event('change'));
            }

            const modeEl = document.getElementById('modeCopy');
            if (modeEl) modeEl.checked = true;

            const direction = downloadWindowsContext.sourcePanel === 'source' ? 'ltr' : 'rtl';
            const started = startTransferWithParams(
                downloadWindowsContext.sourceServer,
                winServer,
                targetPath,
                downloadWindowsContext.files,
                'copy',
                direction,
                null
            );

            if (started) {
                const modalEl = document.getElementById('downloadWindowsModal');
                if (modalEl && typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                    const inst = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
                    inst.hide();
                }
            }
        }

        // é¢„ç½®æœåŠ¡å™¨å…ƒæ•°æ®ï¼ˆç”¨äºæœ¬åœ°åˆ¤å®š Windows/Linuxï¼Œé¿å…é¢å¤–ç½‘ç»œè¯·æ±‚ï¼‰
        const SERVERS_DATA = JSON.parse('{{ servers|tojson }}');
        const REMEMBERED_PATHS = JSON.parse('{{ remembered_paths|tojson }}' || '{}') || {};

        // æ—¥å¿—ç³»ç»Ÿé…ç½®
        let logBuffer = [];
        let logUpdateTimer = null;
        let isTransferring = false;
        const MAX_LOG_ENTRIES = 100;
        const LOG_UPDATE_INTERVAL = 500; // 500msæ‰¹é‡æ›´æ–°
        const runLogBlocks = {};
        let currentRunId = null;
        let socketId = null;
        let imageZoom = 1;
        let imageOffsetX = 0;
        let imageOffsetY = 0;

        // æ™ºèƒ½æ—¥å¿—å‡½æ•°
        function addLog(message, type = 'info') {
            // ä¼ è¾“è¿‡ç¨‹ä¸­è¿‡æ»¤è¯¦ç»†è¿›åº¦ä¿¡æ¯
            if (isTransferring && isProgressMessage(message)) {
                return;
            }

            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp: timestamp,
                message: message,
                type: type,
                id: Date.now() + Math.random()
            };

            // æ·»åŠ åˆ°ç¼“å†²åŒº
            logBuffer.push(logEntry);

            // æ§åˆ¶å°è¾“å‡ºï¼ˆè°ƒè¯•ç”¨ï¼‰
            console.log(`[${timestamp}] ${message}`);

            // æ‰¹é‡æ›´æ–°UI
            scheduleLogUpdate();
        }

        // åˆ¤æ–­æ˜¯å¦ä¸ºè¿›åº¦æ¶ˆæ¯ï¼ˆä¼ è¾“æ—¶éœ€è¦è¿‡æ»¤ï¼‰
        function isProgressMessage(message) {
            const progressKeywords = [
                'å­—èŠ‚', 'bytes', '%', 'MB/s', 'KB/s', 'GB/s',
                'è¿›åº¦', 'progress', 'ä¼ è¾“é€Ÿåº¦', 'å‰©ä½™æ—¶é—´'
            ];
            return progressKeywords.some(keyword => message.includes(keyword));
        }

        // è°ƒåº¦æ—¥å¿—æ›´æ–°
        function scheduleLogUpdate() {
            if (logUpdateTimer) {
                clearTimeout(logUpdateTimer);
            }

            logUpdateTimer = setTimeout(() => {
                updateLogDisplay();
                logUpdateTimer = null;
            }, LOG_UPDATE_INTERVAL);
        }

        // ç«‹å³åˆ·æ–°æ—¥å¿—ï¼Œç¡®ä¿å…³é”®æç¤ºæŒ‰é¡ºåºå‡ºç°
        function flushLogNow() {
            if (logUpdateTimer) {
                clearTimeout(logUpdateTimer);
                logUpdateTimer = null;
            }
            updateLogDisplay();
        }

        // æ›´æ–°æ—¥å¿—æ˜¾ç¤º
        function updateLogDisplay() {
            if (logBuffer.length === 0) return;

            const logContent = document.getElementById('logContent');
            const logContainer = document.getElementById('logContainer');

            // æ‰¹é‡å¤„ç†æ—¥å¿—æ¡ç›®
            const fragment = document.createDocumentFragment();

            logBuffer.forEach(entry => {
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry log-${entry.type}`;
                logDiv.innerHTML = `
                    <span class="log-timestamp">${entry.timestamp}</span>
                    <span class="log-message">${escapeHtml(entry.message)}</span>
                `;
                fragment.appendChild(logDiv);
            });

            logContent.appendChild(fragment);

            // é™åˆ¶æ—¥å¿—æ¡ç›®æ•°é‡
            const entries = logContent.querySelectorAll('.log-entry');
            if (entries.length > MAX_LOG_ENTRIES) {
                const removeCount = entries.length - MAX_LOG_ENTRIES;
                for (let i = 0; i < removeCount; i++) {
                    entries[i].remove();
                }
            }

            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            logContainer.scrollTop = logContainer.scrollHeight;

            // æ¸…ç©ºç¼“å†²åŒº
            logBuffer = [];
        }

        // HTMLè½¬ä¹‰å‡½æ•°
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // æ˜¾ç¤ºæ—¥å¿—æ¨¡æ€çª—å£
        function showLogModal() {
            const logModal = new bootstrap.Modal(document.getElementById('logModal'));
            logModal.show();

            // æ˜¾ç¤ºæ¨¡æ€çª—å£åï¼Œæ»šåŠ¨åˆ°æ—¥å¿—åº•éƒ¨
            setTimeout(() => {
                const logContainer = document.getElementById('logContainer');
                if (logContainer) {
                    logContainer.scrollTop = logContainer.scrollHeight;
                }
            }, 300);
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLog() {
            document.getElementById('logContent').innerHTML = '';
            logBuffer = [];
            addLog('ğŸ“ æ—¥å¿—å·²æ¸…ç©º', 'info');
        }

        // æ·»åŠ ä¸åŒç±»å‹çš„æ—¥å¿—å‡½æ•°
        function addLogInfo(message) {
            addLog(message, 'info');
        }

        function addLogSuccess(message) {
            addLog(message, 'success');
        }

        // å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼ˆä¼˜å…ˆä½¿ç”¨å®‰å…¨APIï¼‰
        function copyTextToClipboard(text) {
            if (navigator.clipboard && window.isSecureContext) {
                return navigator.clipboard.writeText(text);
            } else {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.focus();
                textarea.select();
                try {
                    document.execCommand('copy');
                    return Promise.resolve();
                } catch (e) {
                    return Promise.reject(e);
                } finally {
                    document.body.removeChild(textarea);
                }
            }
        }

        // å¤åˆ¶å½“å‰é¢æ¿è·¯å¾„ï¼ˆsource/targetï¼‰
        function copyPath(type) {
            const text = type === 'source' ? (currentSourcePath || '') : (currentTargetPath || '');
            if (!text) {
                addLogWarning('âš ï¸ å½“å‰è·¯å¾„ä¸ºç©ºï¼Œæ— æ³•å¤åˆ¶');
                return;
            }
            copyTextToClipboard(text)
                .then(() => addLogSuccess(`ğŸ“‹ å·²å¤åˆ¶è·¯å¾„: ${text}`))
                .catch(() => addLogWarning('âš ï¸ å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶'));
        }

        // åˆ é™¤é€‰ä¸­çš„æ–‡ä»¶/æ–‡ä»¶å¤¹
        async function deleteSelected(type) {
            const selectedFiles = type === 'source' ? selectedSourceFiles : selectedTargetFiles;
            const server = type === 'source' ? document.getElementById('sourceServer').value : document.getElementById('targetServer').value;
            const currentPath = type === 'source' ? currentSourcePath : currentTargetPath;

            if (!server) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æœåŠ¡å™¨');
                return;
            }

            if (selectedFiles.length === 0) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                return;
            }

            // ç¡®è®¤åˆ é™¤
            const fileNames = selectedFiles.map(f => f.name).join('\n');
            const confirmMsg = `ç¡®å®šè¦åˆ é™¤ä»¥ä¸‹ ${selectedFiles.length} é¡¹å—ï¼Ÿ\n\n${fileNames}\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ¢å¤ï¼`;
            if (!confirm(confirmMsg)) {
                return;
            }

            try {
                // æ„å»ºå®Œæ•´è·¯å¾„åˆ—è¡¨
                const paths = selectedFiles.map(f => f.path);

                const response = await fetch('/api/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        server: server,
                        paths: paths
                    })
                });

                const result = await response.json();

                // åªè¦æœ‰æˆåŠŸåˆ é™¤çš„æ•°é‡ï¼Œå°±åˆ·æ–°æµè§ˆåŒºï¼›å¤±è´¥é¡¹å•ç‹¬æç¤º
                if (result.success || (result.deleted_count && result.deleted_count > 0)) {
                    // æ¸…ç©ºé€‰ä¸­çŠ¶æ€
                    if (type === 'source') {
                        selectedSourceFiles = [];
                    } else {
                        selectedTargetFiles = [];
                    }

                    // åˆ·æ–°ç›®å½•ï¼ˆå¼ºåˆ¶åˆ·æ–°ï¼Œåç«¯å·²æ¸…ç†ç¼“å­˜ï¼‰
                    if (type === 'source') {
                        await refreshSourceAsync();
                    } else {
                        await refreshTargetAsync();
                    }

                    // è‹¥å­˜åœ¨å¤±è´¥é¡¹ï¼Œç»§ç»­æç¤ºä½†ä¸é˜»æ­¢åˆ·æ–°
                    if (!result.success && result.failed_items && result.failed_items.length > 0) {
                        addLogWarning(`âš ï¸ éƒ¨åˆ†åˆ é™¤å¤±è´¥ï¼Œå…± ${result.failed_items.length} é¡¹`);
                        result.failed_items.forEach(item => {
                            addLogError(`  - ${item.path}: ${item.error}`);
                        });
                    }
                } else {
                    addLogError(`âŒ åˆ é™¤å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
                    if (result.failed_items && result.failed_items.length > 0) {
                        result.failed_items.forEach(item => {
                            addLogError(`  - ${item.path}: ${item.error}`);
                        });
                    }
                }
            } catch (error) {
                addLogError(`âŒ åˆ é™¤æ“ä½œå¼‚å¸¸: ${error.message}`);
            }
        }

        // æ˜¾ç¤ºåˆ›å»ºæ–‡ä»¶å¤¹å¯¹è¯æ¡†
        function showCreateFolderDialog(type) {
            const server = type === 'source' ? document.getElementById('sourceServer').value : document.getElementById('targetServer').value;
            const currentPath = type === 'source' ? currentSourcePath : currentTargetPath;

            if (!server) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æœåŠ¡å™¨');
                return;
            }

            if (!currentPath) {
                addLogWarning('âš ï¸ è¯·å…ˆæµè§ˆåˆ°ç›®æ ‡ç›®å½•');
                return;
            }

            const folderName = prompt('è¯·è¾“å…¥æ–°æ–‡ä»¶å¤¹åç§°:', 'æ–°å»ºæ–‡ä»¶å¤¹');
            if (!folderName || folderName.trim() === '') {
                return;
            }

            createFolder(type, server, currentPath, folderName.trim());
        }

        // åˆ›å»ºæ–‡ä»¶å¤¹
        async function createFolder(type, server, parentPath, folderName) {
            try {
                addLogInfo(`ğŸ“ æ­£åœ¨åˆ›å»ºæ–‡ä»¶å¤¹: ${folderName}...`);

                const response = await fetch('/api/create_folder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        server: server,
                        parent_path: parentPath,
                        folder_name: folderName
                    })
                });

                const result = await response.json();

                if (result.success) {
                    addLogSuccess(`âœ… ${result.message}`);

                    // åˆ·æ–°ç›®å½•
                    if (type === 'source') {
                        await refreshSourceAsync();
                    } else {
                        await refreshTargetAsync();
                    }
                } else {
                    addLogError(`âŒ åˆ›å»ºæ–‡ä»¶å¤¹å¤±è´¥: ${result.error}`);
                }
            } catch (error) {
                addLogError(`âŒ åˆ›å»ºæ–‡ä»¶å¤¹å¼‚å¸¸: ${error.message}`);
            }
        }

        // åˆ›å»ºç©ºæ–‡ä»¶
        async function createFile(type, server, parentPath, fileName) {
            try {
                addLogInfo(`ğŸ“„ æ­£åœ¨åˆ›å»ºæ–‡ä»¶: ${fileName}...`);
                const response = await fetch('/api/create_file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        server: server,
                        parent_path: parentPath,
                        file_name: fileName
                    })
                });
                const result = await response.json();
                if (result.success) {
                    addLogSuccess(`âœ… ${result.message || 'åˆ›å»ºæ–‡ä»¶æˆåŠŸ'}`);
                    if (type === 'source') {
                        await refreshSourceAsync();
                    } else {
                        await refreshTargetAsync();
                    }
                } else {
                    addLogError(`âŒ åˆ›å»ºæ–‡ä»¶å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (error) {
                addLogError(`âŒ åˆ›å»ºæ–‡ä»¶å¼‚å¸¸: ${error.message}`);
            }
        }

        // æ˜¾ç¤ºé‡å‘½åå¯¹è¯æ¡†
        function showRenameDialog(type) {
            const selectedFiles = type === 'source' ? selectedSourceFiles : selectedTargetFiles;
            const server = type === 'source' ? document.getElementById('sourceServer').value : document.getElementById('targetServer').value;

            if (!server) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æœåŠ¡å™¨');
                return;
            }

            if (selectedFiles.length === 0) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©è¦é‡å‘½åçš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                return;
            }

            if (selectedFiles.length > 1) {
                addLogWarning('âš ï¸ ä¸€æ¬¡åªèƒ½é‡å‘½åä¸€ä¸ªæ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                return;
            }

            const file = selectedFiles[0];
            const oldName = file.name;
            const newName = prompt(`è¯·è¾“å…¥æ–°åç§°:\n\nåŸåç§°: ${oldName}`, oldName);

            if (!newName || newName.trim() === '') {
                return;
            }

            if (newName === oldName) {
                addLogWarning('âš ï¸ æ–°åç§°ä¸åŸåç§°ç›¸åŒ');
                return;
            }

            renameFile(type, server, file.path, newName.trim());
        }

        // é‡å‘½åæ–‡ä»¶æˆ–æ–‡ä»¶å¤¹
        async function renameFile(type, server, oldPath, newName) {
            try {
                addLogInfo(`âœï¸ æ­£åœ¨é‡å‘½åä¸º: ${newName}...`);

                const response = await fetch('/api/rename', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        server: server,
                        old_path: oldPath,
                        new_name: newName
                    })
                });

                const result = await response.json();

                if (result.success) {
                    addLogSuccess(`âœ… ${result.message}`);

                    // æ¸…ç©ºé€‰ä¸­çŠ¶æ€
                    if (type === 'source') {
                        selectedSourceFiles = [];
                    } else {
                        selectedTargetFiles = [];
                    }

                    // åˆ·æ–°ç›®å½•
                    if (type === 'source') {
                        await refreshSourceAsync();
                    } else {
                        await refreshTargetAsync();
                    }
                } else {
                    addLogError(`âŒ é‡å‘½åå¤±è´¥: ${result.error}`);
                }
            } catch (error) {
                addLogError(`âŒ é‡å‘½åå¼‚å¸¸: ${error.message}`);
            }
        }

        // åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å¯è¿è¡Œï¼ˆä»… .py / .shï¼‰
        function isRunnableFileName(name) {
            if (!name) return false;
            const lower = name.toLowerCase();
            return lower.endsWith('.py') || lower.endsWith('.sh');
        }

        function addLogWarning(message) {
            addLog(message, 'warning');
        }

        function addLogError(message) {
            addLog(message, 'error');
        }

        function updateRunControls() {
            const stopBtn = document.getElementById('runStopBtn');
            const sendBtn = document.getElementById('runSendBtn');
            const input = document.getElementById('runInputBox');
            const disabled = !currentRunId;
            if (stopBtn) stopBtn.disabled = disabled;
            if (sendBtn) sendBtn.disabled = disabled;
            if (input) input.disabled = disabled;
        }

        function logCommandOutput(text, isError = false) {
            if (!text) return;
            const lines = text.split(/\r?\n/).filter(line => line.trim() !== '');
            lines.forEach(line => addLog(line, isError ? 'error' : 'info'));
        }

        async function cancelCurrentRun() {
            if (!currentRunId) {
                addLogWarning('å½“å‰æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„è„šæœ¬');
                return;
            }
            try {
                const resp = await fetch('/api/run_file/cancel', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ run_id: currentRunId })
                });
                const result = await resp.json();
                if (result.success) {
                    addLogWarning('â¹ï¸ å·²å‘é€ä¸­æ–­è¯·æ±‚');
                } else {
                    addLogError(`âŒ ä¸­æ–­å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (err) {
                addLogError(`âŒ ä¸­æ–­å¼‚å¸¸: ${err.message}`);
            }
        }

        async function sendRunInput() {
            const inputEl = document.getElementById('runInputBox');
            if (!inputEl) return;
            const val = inputEl.value;
            if (!val || !val.trim()) return;
            if (!currentRunId) {
                addLogWarning('å½“å‰æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„è„šæœ¬');
                return;
            }
            try {
                const resp = await fetch('/api/run_file/input', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ run_id: currentRunId, data: val })
                });
                const result = await resp.json();
                if (!result.success) {
                    addLogError(`âŒ å‘é€è¾“å…¥å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (err) {
                addLogError(`âŒ å‘é€è¾“å…¥å¼‚å¸¸: ${err.message}`);
            } finally {
                inputEl.value = '';
            }
        }

        function appendRunLog(runId, text, isError = false, isFinal = false, exitCode = null) {
            if (!text && !isFinal) return;
            const logContent = document.getElementById('logContent');
            const logContainer = document.getElementById('logContainer');
            if (!logContent) return;

            let block = runLogBlocks[runId];
            if (!block) {
                block = document.createElement('div');
                block.className = `log-entry ${isError ? 'log-error' : 'log-info'}`;
                const time = new Date().toLocaleTimeString();
                block.innerHTML = `
                    <span class="log-timestamp">${time}</span>
                    <pre class="log-run-block"></pre>
                `;
                logContent.appendChild(block);
                runLogBlocks[runId] = block;
                // åˆå§‹åŒ–è¿›åº¦æ¡çŠ¶æ€ï¼šå­˜å‚¨å½“å‰è¡Œå†…å®¹ï¼Œç”¨äº \r å›è½¦è¦†ç›–
                block._currentLine = '';
            }

            const pre = block.querySelector('.log-run-block');
            if (pre && text) {
                // å¤„ç† \r å›è½¦ç¬¦å®ç°åŸåœ°æ›´æ–°ï¼ˆè¿›åº¦æ¡æ•ˆæœï¼‰
                // åˆå§‹åŒ–æˆ–è·å–å·²ä¿å­˜çš„å®Œæˆè¡Œå†…å®¹
                if (block._completedLines === undefined) {
                    block._completedLines = '';
                }
                let completedLines = block._completedLines;
                let currentLine = block._currentLine || '';

                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    if (char === '\r') {
                        // å›è½¦ç¬¦ï¼šæ¸…ç©ºå½“å‰è¡Œï¼ˆä¸‹ä¸€ä¸ªå­—ç¬¦ä¼šè¦†ç›–ï¼‰
                        // å¦‚æœä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ \nï¼Œåˆ™è·³è¿‡ï¼ˆWindows çš„ \r\nï¼‰
                        if (text[i + 1] === '\n') {
                            continue; // è®© \n å¤„ç†æ¢è¡Œ
                        }
                        // å•ç‹¬çš„ \rï¼šè¦†ç›–å½“å‰è¡Œï¼ˆå®ç°è¿›åº¦æ¡åŸåœ°æ›´æ–°ï¼‰
                        currentLine = '';
                    } else if (char === '\n') {
                        // æ¢è¡Œç¬¦ï¼šå°†å½“å‰è¡Œè¿½åŠ åˆ°å·²å®Œæˆè¡Œï¼Œå¹¶å¼€å§‹æ–°è¡Œ
                        completedLines += currentLine + '\n';
                        currentLine = '';
                    } else {
                        // æ™®é€šå­—ç¬¦ï¼šè¿½åŠ åˆ°å½“å‰è¡Œ
                        currentLine += char;
                    }
                }

                // ä¿å­˜çŠ¶æ€
                block._completedLines = completedLines;
                block._currentLine = currentLine;
                // æ›´æ–° pre çš„å†…å®¹ï¼ˆå·²å®Œæˆçš„è¡Œ + å½“å‰æ­£åœ¨ç¼–è¾‘çš„è¡Œï¼‰
                pre.textContent = completedLines + currentLine;
            }

            if (isFinal && pre) {
                if (exitCode !== null && text.indexOf('é€€å‡ºç ') === -1) {
                    pre.textContent += `\n[exit ${exitCode}]`;
                }
            }

            block.className = `log-entry ${isError ? 'log-error' : 'log-info'}`;

            if (logContainer) {
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            if (isFinal) {
                delete runLogBlocks[runId];
            }
        }

        // è¿è¡Œè¿œç«¯/æœ¬åœ°æ–‡ä»¶ï¼ˆä»… .py / .shï¼‰
        async function runFileOnServer(server, filePath, fileName) {
            if (!server) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æœåŠ¡å™¨');
                return;
            }
            if (!filePath) {
                addLogWarning('âš ï¸ æœªæ‰¾åˆ°è¦è¿è¡Œçš„æ–‡ä»¶');
                return;
            }

            addLogInfo(`â–¶ï¸ æ­£åœ¨è¿è¡Œ: ${fileName || filePath}`);
            // ç«‹å³åˆ·æ–°æ—¥å¿—ï¼Œç¡®ä¿è¿™æ¡æç¤ºå…ˆå‡ºç°
            if (typeof flushLogNow === 'function') {
                flushLogNow();
            }

            try {
                const resp = await fetch('/api/run_file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ server: server, path: filePath, sid: socket.id })
                });

                const result = await resp.json();

                if (result.success) {
                    const runId = result.run_id || '';
                    currentRunId = runId || null;
                    updateRunControls();
                } else {
                    addLogError(`âŒ è¿è¡Œå¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (error) {
                addLogError(`âŒ è¿è¡Œå¼‚å¸¸: ${error.message}`);
            }
        }

        // è®¡ç®—æ–‡ä»¶/æ–‡ä»¶å¤¹å¤§å°
        async function computeSizeOnServer(server, filePath, fileName) {
            if (!server) {
                addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æœåŠ¡å™¨');
                return;
            }
            if (!filePath) {
                addLogWarning('âš ï¸ æœªæ‰¾åˆ°è¦è®¡ç®—çš„è·¯å¾„');
                return;
            }
            addLogInfo(`ğŸ“¦ æ­£åœ¨è®¡ç®—å¤§å°: ${fileName || filePath}`);
            if (typeof flushLogNow === 'function') flushLogNow();
            try {
                const resp = await fetch('/api/compute_size', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ server: server, path: filePath })
                });
                const result = await resp.json();
                if (result.success) {
                    addLogSuccess(`ğŸ“ å¤§å°: ${result.human_size || result.size_bytes + ' bytes'} (${fileName || filePath})`);
                } else {
                    addLogError(`âŒ è®¡ç®—å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (err) {
                addLogError(`âŒ è®¡ç®—å¼‚å¸¸: ${err.message}`);
            }
        }

        // å‹ç¼©
        async function compressPathOnServer(server, filePath, fileName) {
            try {
                const resp = await fetch('/api/compress', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ server: server, path: filePath })
                });
                const result = await resp.json();
                if (result.success) {
                    addLogSuccess(`ğŸ—œï¸ å‹ç¼©å®Œæˆ: ${result.zip_name || fileName + '.zip'}`);
                } else {
                    addLogError(`âŒ å‹ç¼©å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (err) {
                addLogError(`âŒ å‹ç¼©å¼‚å¸¸: ${err.message}`);
            }
        }

        // è§£å‹
        async function extractArchiveOnServer(server, filePath, fileName) {
            try {
                const resp = await fetch('/api/extract', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ server: server, path: filePath })
                });
                const result = await resp.json();
                if (result.success) {
                    addLogSuccess(`ğŸ“‚ è§£å‹å®Œæˆ: ${fileName}`);
                } else {
                    addLogError(`âŒ è§£å‹å¤±è´¥: ${result.error || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (err) {
                addLogError(`âŒ è§£å‹å¼‚å¸¸: ${err.message}`);
            }
        }

        function getPanelConfig(isSource) {
            return {
                serverSelect: isSource ? 'sourceServer' : 'targetServer',
                showHiddenCheckbox: isSource ? 'sourceShowHidden' : 'targetShowHidden',
                containerId: isSource ? 'sourceFileBrowser' : 'targetFileBrowser'
            };
        }

        function resetBrowseState(isSource, path) {
            const state = isSource ? browseState.source : browseState.target;
            state.path = path;
            state.offset = 0;
            state.total = 0;
            state.hasMore = false;
            state.loadedCount = 0;
            state.requestToken = `${Date.now()}_${Math.random()}`;
            if (state.controller) {
                try { state.controller.abort(); } catch (_) {}
                state.controller = null;
            }
        }

        function clearSelectionsForPanel(isSource) {
            if (isSource) {
                selectedSourceFiles = [];
            } else {
                selectedTargetFiles = [];
            }
            const containerId = isSource ? 'sourceFileBrowser' : 'targetFileBrowser';
            document.querySelectorAll(`#${containerId} .file-item.selected`).forEach(el => el.classList.remove('selected'));
        }

        function updateFileCountDisplay(isSource, loaded, total) {
            const el = document.getElementById(isSource ? 'sourceFileCount' : 'targetFileCount');
            if (!el) return;
            if (total) {
                el.textContent = `å·²åŠ è½½ ${loaded}/${total} é¡¹`;
            } else {
                el.textContent = `å…± ${loaded} é¡¹`;
            }
        }

        function showLoading(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML = '<div class="text-center text-muted p-2" style="font-size: 0.8rem;">åŠ è½½ä¸­...</div>';
            }
        }

        function getActivePath(isSource) {
            return isSource ? currentSourcePath : currentTargetPath;
        }

        async function loadDirectory(type, targetPath, options = {}) {
            const isSource = type === 'source';
            const state = isSource ? browseState.source : browseState.target;
            const { serverSelect, showHiddenCheckbox, containerId } = getPanelConfig(isSource);
            const server = document.getElementById(serverSelect).value;
            const showHidden = document.getElementById(showHiddenCheckbox).checked;
            const forceRefresh = options.forceRefresh === true;
            const isReset = options.reset === true || state.path !== targetPath || state.loadedCount === 0;

            if (!server) {
                alert(isSource ? 'è¯·å…ˆé€‰æ‹©æºæœåŠ¡å™¨' : 'è¯·å…ˆé€‰æ‹©ç›®æ ‡æœåŠ¡å™¨');
                return;
            }

        if (isReset) {
            resetBrowseState(isSource, targetPath);
            clearSelectionsForPanel(isSource);
            showLoading(containerId);
        } else {
            if (state.loading || !state.hasMore) {
                return;
            }
        }

            const controller = new AbortController();
            if (state.controller) {
                try { state.controller.abort(); } catch (_) {}
            }
            state.controller = controller;
            state.loading = true;
            const requestToken = `${Date.now()}_${Math.random()}`;
            state.requestToken = requestToken;

            // â€œåˆ·æ–°ç›®å½•â€å¿…é¡»åŒæ­¥æ¸…ç†é¢„è§ˆç¼“å­˜ï¼Œå¦åˆ™åŒè·¯å¾„æ–‡ä»¶è¢«åˆ é™¤/é‡å»º/è¦†ç›–æ—¶ä¼šç»§ç»­å‘½ä¸­å†…å­˜ç¼“å­˜ï¼Œå¯¼è‡´å‰ç«¯æ˜¾ç¤ºæ—§å†…å®¹
            if (forceRefresh) {
                invalidatePreviewCacheUnderDir(server, targetPath);
            }

            const params = new URLSearchParams({
                path: targetPath,
                show_hidden: showHidden,
                offset: state.offset,
                limit: BROWSE_PAGE_SIZE,
                force_refresh: forceRefresh
            });

            try {
                const response = await fetch(`/api/browse/${server}?${params.toString()}`, {
                    signal: controller.signal,
                    cache: forceRefresh ? 'no-cache' : 'default'
                });

                const data = await response.json();

                // å¦‚æœæœŸé—´è·¯å¾„å·²åˆ‡æ¢æˆ–è¯·æ±‚è¢«æ›¿æ¢ï¼Œç›´æ¥ä¸¢å¼ƒç»“æœ
                const activePath = getActivePath(isSource);
                if (state.requestToken !== requestToken || activePath !== targetPath) {
                    return;
                }

                if (data.success) {
                    const pageFiles = data.files || [];
                const total = data.total_count || data.file_count || 0;
                const startIndex = state.loadedCount;

                state.total = total;
                state.loadedCount = data.loaded_count || (state.loadedCount + pageFiles.length);
                state.hasMore = data.has_more;
                state.offset = data.next_offset ?? state.loadedCount;
                // ç»´æŠ¤å…¨é‡åˆ—è¡¨ï¼ˆç”¨äºå…¨é€‰/å›¾ç‰‡æµè§ˆï¼‰
                if (isReset) {
                    state.fullItems = [];
                    state.fullOffset = 0;
                    state.fullHasMore = false;
                }
                state.fullItems = (state.fullItems || []).concat(pageFiles);
                state.fullOffset = data.next_offset ?? state.loadedCount;
                state.fullHasMore = data.has_more;

                displayFiles(containerId, pageFiles, targetPath, isSource, {
                    append: !isReset && startIndex > 0,
                    totalCount: total,
                    loadedCount: state.loadedCount,
                        startIndex: startIndex
                    });
                    updateFileCountDisplay(isSource, state.loadedCount, total);
                    state.path = targetPath;
                    if (server && targetPath) {
                        saveClientPath(isSource ? 'source' : 'target', server, targetPath);
                    }

                    // åŠ è½½ç›®å½•çš„æç¤ºä¸å†å†™å…¥æ—¥å¿—ï¼Œä¿æŒæ—¥å¿—å¹²å‡€
                    if (state.hasMore) {
                        setTimeout(() => handleScrollLoadMore(isSource), 0);
                    }
                } else {
                    state.hasMore = false;
                    showErrorState(containerId, 'æµè§ˆå¤±è´¥: ' + data.error);
                    addLogError(`âŒ æµè§ˆ${isSource ? 'æº' : 'ç›®æ ‡'}ç›®å½•å¤±è´¥: ${data.error}`);
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error:', error);
                    showErrorState(containerId, 'æµè§ˆå¤±è´¥: ' + error.message);
                    addLogError(`âŒ æµè§ˆ${isSource ? 'æº' : 'ç›®æ ‡'}ç›®å½•å‡ºé”™: ${error}`);
                }
                state.hasMore = false;
            } finally {
                state.loading = false;
            }
        }

        // æµè§ˆ/åˆ·æ–°å…¥å£ï¼ˆå‘ä¸‹å…¼å®¹æ—§è°ƒç”¨ï¼‰
        function browseSource() {
            loadDirectory('source', currentSourcePath, { reset: true });
        }

        function refreshSource() {
            loadDirectory('source', currentSourcePath, { reset: true, forceRefresh: true });
        }

        async function browseSourceAsync() {
            return loadDirectory('source', currentSourcePath, { reset: true });
        }

        async function browseSourceInstant(targetPath) {
            currentSourcePath = targetPath;
            return loadDirectory('source', targetPath, { reset: true });
        }

        async function refreshSourceAsync() {
            return loadDirectory('source', currentSourcePath, { reset: true, forceRefresh: true });
        }

        function browseTarget() {
            loadDirectory('target', currentTargetPath, { reset: true });
        }

        function refreshTarget() {
            loadDirectory('target', currentTargetPath, { reset: true, forceRefresh: true });
        }

        async function browseTargetAsync() {
            return loadDirectory('target', currentTargetPath, { reset: true });
        }

        async function browseTargetInstant(targetPath) {
            currentTargetPath = targetPath;
            return loadDirectory('target', targetPath, { reset: true });
        }

        async function saveClientPath(panel, server, path) {
            if (!panel || !server || !path) return;
            updateRememberedCache(panel, server, path);
            try {
                await fetch('/api/client_path/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ panel, server, path })
                });
            } catch (_) {
                // å¿½ç•¥å¤±è´¥
            }
        }

        async function refreshTargetAsync() {
            return loadDirectory('target', currentTargetPath, { reset: true, forceRefresh: true });
        }

        // æ»šåŠ¨åˆ°åº•éƒ¨è‡ªåŠ¨åŠ è½½æ›´å¤š
        function handleScrollLoadMore(isSource) {
            const containerId = isSource ? 'sourceFileBrowser' : 'targetFileBrowser';
            const container = document.getElementById(containerId);
            const state = isSource ? browseState.source : browseState.target;
            if (!container || state.loading || !state.hasMore) return;

            const threshold = container.scrollHeight - container.clientHeight - 120;
            if (container.scrollTop >= threshold) {
                loadDirectory(isSource ? 'source' : 'target', state.path || getActivePath(isSource), { reset: false });
            }
        }

        // åˆ‡æ¢éšè—æ–‡ä»¶æ˜¾ç¤º
        function toggleHiddenFiles(type) {
            if (type === 'source') {
                const server = document.getElementById('sourceServer').value;
                if (server && currentSourcePath) {
                    browseSource();
                }
            } else if (type === 'target') {
                const server = document.getElementById('targetServer').value;
                if (server && currentTargetPath) {
                    browseTarget();
                }
            }
        }

        // WinSCPé£æ ¼çš„æ–‡ä»¶æ’åºå‡½æ•°
        function sortFilesWinSCPStyle(files) {
            return files.sort((a, b) => {
                // 1. æ–‡ä»¶å¤¹ä¼˜å…ˆæ˜¾ç¤ºåœ¨æ–‡ä»¶ä¹‹å‰
                if (a.is_directory && !b.is_directory) {
                    return -1;
                }
                if (!a.is_directory && b.is_directory) {
                    return 1;
                }

                // 2. åŒç±»å‹å†…æŒ‰æ–‡ä»¶åå­—æ¯é¡ºåºæ’åºï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰
                const nameA = a.name.toLowerCase();
                const nameB = b.name.toLowerCase();

                // 3. è‡ªç„¶æ’åºï¼ˆæ­£ç¡®å¤„ç†æ•°å­—ï¼‰
                return nameA.localeCompare(nameB, undefined, {
                    numeric: true,
                    sensitivity: 'base'
                });
            });
        }

        // æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
        function displayFiles(containerId, files, currentPath, isSource, options = {}) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const append = options.append === true;
            const totalCount = options.totalCount ?? null;
            const loadedCount = options.loadedCount ?? null;
            const startIndex = options.startIndex || 0;

            const pathChanged = container.dataset.currentPath !== currentPath;
            const shouldReset = !append || pathChanged;

            if (shouldReset) {
                container.dataset.currentPath = currentPath;
                container.innerHTML = '';
                updatePathNavigation(currentPath, isSource);

                if (currentPath !== '/') {
                    const parentPath = getParentPath(currentPath);
                    const backRow = document.createElement('div');
                    backRow.className = 'file-item';
                    backRow.title = 'åŒå‡»è¿”å›ä¸Šçº§ç›®å½•';
                    backRow.ondblclick = () => navigateTo(containerId, parentPath, isSource);
                    backRow.innerHTML = `
                        <i class="bi bi-arrow-up-circle text-primary"></i>
                        <div class="file-info">
                            <span class="file-name">..</span>
                            <span class="file-details" style="font-size: 0.75rem; color: #6c757d;">åŒå‡»è¿”å›ä¸Šçº§</span>
                        </div>
                    `;
                    container.appendChild(backRow);
                }
            } else {
                // è¿½åŠ æ—¶ç§»é™¤æ—§çš„åº•éƒ¨é—´è·
                container.querySelectorAll('.file-browser-spacer').forEach(el => el.remove());
            }

            // åº”ç”¨WinSCPé£æ ¼æ’åºï¼ˆä¿æŒä¸åç«¯ä¸€è‡´ï¼‰
            const sortedFiles = sortFilesWinSCPStyle([...files]);

            const fragment = document.createDocumentFragment();
            sortedFiles.forEach((file, index) => {
                const icon = file.is_directory ? 'bi-folder-fill text-warning' : 'bi-file-earmark text-info';
                const size = file.is_directory ? '' : formatFileSize(file.size);
                const fileId = `file_${containerId}_${startIndex + index}`;
                const fileIdx = startIndex + index;

                const row = document.createElement('div');
                row.className = 'file-item selectable';
                row.id = fileId;
                row.dataset.path = file.path;
                row.dataset.name = file.name;
                row.dataset.isDirectory = file.is_directory;
                row.dataset.idx = fileIdx;
                row.onmousedown = (event) => handleFileMouseDown(event, file.path, file.name, file.is_directory, fileId, isSource);
                row.ondblclick = function() { handleFileItemDblClick(row, isSource); };
                row.innerHTML = `
                    <i class="bi ${icon}"></i>
                    <div class="file-info">
                        <span class="file-name">${file.name}</span>
                        <span class="file-details">${size} ${file.modified}</span>
                    </div>
                `;

                fragment.appendChild(row);
            });

            container.appendChild(fragment);

            // é‡æ–°æ·»åŠ åº•éƒ¨é—´è·ç¡®ä¿æœ€åä¸€ä¸ªæ–‡ä»¶å¯è§
            const spacer = document.createElement('div');
            spacer.className = 'file-browser-spacer';
            spacer.style.height = '20px';
            container.appendChild(spacer);

            const loaded = loadedCount !== null ? loadedCount : container.querySelectorAll('.file-item.selectable').length;
            const total = totalCount !== null ? totalCount : loaded;
            updateFileCountDisplay(isSource, loaded, total);
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes === 0) return '';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + sizes[i];
        }

        // å¯¼èˆªåˆ°ç›®å½•ï¼ˆæ— åŠ è½½åŠ¨ç”»ç‰ˆæœ¬ï¼‰
        function navigateTo(containerId, path, isSource) {
            if (isSource) {
                currentSourcePath = path;
                // ç›´æ¥ä½¿ç”¨å³æ—¶æµè§ˆï¼Œæ— åŠ è½½åŠ¨ç”»
                browseSourceInstant(path);
            } else {
                currentTargetPath = path;
                // ç›´æ¥ä½¿ç”¨å³æ—¶æµè§ˆï¼Œæ— åŠ è½½åŠ¨ç”»
                browseTargetInstant(path);
            }
        }

        // åŒå‡»é…ç½® - å‚è€ƒWinSCPç­‰ä¸“ä¸šæ–‡ä»¶ç®¡ç†å™¨çš„æ ‡å‡†
        const DOUBLE_CLICK_CONFIG = {
            timeWindow: 300,  // åŒå‡»æ—¶é—´çª—å£ï¼ˆæ¯«ç§’ï¼‰- æ¯”æ ‡å‡†200msæ›´å®½å®¹
            debounceDelay: 50 // é˜²æŠ–å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰- æé«˜å“åº”é€Ÿåº¦
        };

        // äº¤äº’ä¼˜åŒ–é…ç½®
        const INTERACTION_CONFIG = {
            immediateVisualFeedback: true,  // ç«‹å³è§†è§‰åé¦ˆ
            removeAllAnimations: true,      // ç§»é™¤æ‰€æœ‰åŠ¨ç”»æ•ˆæœ
            staticHoverEffects: true        // é™æ€æ‚¬åœæ•ˆæœ
        };

        // æ™ºèƒ½é¼ æ ‡äº‹ä»¶å¤„ç† - åŒºåˆ†å•å‡»å’ŒåŒå‡»ï¼ˆä¼˜åŒ–åŒå‡»å“åº”ï¼‰
        let clickTimer = null;
        let clickCount = 0;

        function handleFileMouseDown(event, path, name, isDirectory, fileId, isSource) {
            if (event.button !== 0) return; // ä»…å·¦é”®
            event.preventDefault();

            lastActivePanel = isSource ? 'source' : 'target';

            // ç«‹å³å¤„ç†è§†è§‰åé¦ˆ - ä¸åŒå‡»æ£€æµ‹åˆ†ç¦»
            if (fileId) {
                // ç«‹å³æ˜¾ç¤ºé€‰ä¸­çŠ¶æ€ï¼Œæ— å»¶è¿Ÿ
                selectFileImmediate(event, path, name, isDirectory, fileId, isSource);
            }

            clickCount++;

            if (clickCount === 1) {
                // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Œè®¾ç½®å»¶è¿Ÿå¤„ç†é€»è¾‘æ“ä½œï¼ˆéè§†è§‰åé¦ˆï¼‰
                clickTimer = setTimeout(() => {
                    // å•å‡»é€»è¾‘å¤„ç†ï¼ˆè§†è§‰åé¦ˆå·²ç»ç«‹å³å¤„ç†äº†ï¼‰
                    clickCount = 0;
                }, DOUBLE_CLICK_CONFIG.timeWindow); // ä½¿ç”¨é…ç½®çš„åŒå‡»æ—¶é—´çª—å£
            } else if (clickCount === 2) {
                // åŒå‡»å¤„ç† - ç«‹å³å“åº”ï¼Œæ— åŠ è½½åŠ¨ç”»
                clearTimeout(clickTimer);
                clickCount = 0;

                if (isDirectory) {
                    // ç«‹å³å“åº”åŒå‡»ï¼Œæ— å»¶è¿Ÿï¼Œæ— åŠ è½½åŠ¨ç”»
                    console.log(`[åŒå‡»] ç«‹å³è¿›å…¥ç›®å½•: ${path}`);

                    // ç«‹å³æ›´æ–°è·¯å¾„
                    if (isSource) {
                        currentSourcePath = path;
                        // ç›´æ¥å¼€å§‹å¼‚æ­¥åŠ è½½ï¼Œä¸æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                        browseSourceInstant(path);
                    } else {
                        currentTargetPath = path;
                        // ç›´æ¥å¼€å§‹å¼‚æ­¥åŠ è½½ï¼Œä¸æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                        browseTargetInstant(path);
                    }
                }
            }
        }

        // å¤„ç†åŒå‡»äº‹ä»¶ - ä¿æŒå…¼å®¹æ€§ï¼ˆæ— åŠ è½½åŠ¨ç”»ç‰ˆæœ¬ï¼‰
        function handleDoubleClick(path, isDirectory, isSource) {
            if (!isDirectory) return;

            // ç«‹å³å“åº”ï¼Œæ— å»¶è¿Ÿï¼Œæ— åŠ è½½åŠ¨ç”»
            console.log(`[åŒå‡»] ç«‹å³è¿›å…¥ç›®å½•: ${path}`);

            // ç«‹å³æ›´æ–°è·¯å¾„
            if (isSource) {
                currentSourcePath = path;
                // ç›´æ¥å¼€å§‹å¼‚æ­¥åŠ è½½ï¼Œä¸æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                browseSourceInstant(path);
            } else {
                currentTargetPath = path;
                // ç›´æ¥å¼€å§‹å¼‚æ­¥åŠ è½½ï¼Œä¸æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                browseTargetInstant(path);
            }
        }

        // æ³¨æ„ï¼šåŠ è½½åŠ¨ç”»ç›¸å…³å‡½æ•°å·²ç§»é™¤ï¼Œå®ç°æ— æ„ŸåŒå‡»è¿›å…¥æ–‡ä»¶å¤¹

        // åˆ·æ–°çŠ¶æ€å‡½æ•°å·²ç§»é™¤ï¼Œå®ç°æ— æ„Ÿåˆ·æ–°

        // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
        function showErrorState(containerId, errorMessage) {
            const container = document.getElementById(containerId);
            container.innerHTML = `
                <div class="text-center p-4">
                    <div class="text-danger mb-3">
                        <i class="bi bi-exclamation-triangle-fill" style="font-size: 2rem;"></i>
                    </div>
                    <div class="text-danger">${errorMessage}</div>
                    <button class="btn btn-outline-primary btn-sm mt-3" onclick="location.reload()">
                        <i class="bi bi-arrow-clockwise"></i> é‡æ–°åŠ è½½
                    </button>
                </div>
            `;
        }

        // é˜²æŠ–å‡½æ•° - é˜²æ­¢å¿«é€Ÿé‡å¤æ“ä½œ
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ä¼˜åŒ–çš„åŒå‡»å¤„ç† - æ·»åŠ é˜²æŠ–ï¼ˆä¼˜åŒ–åŒå‡»å“åº”ï¼‰
        const debouncedHandleDoubleClick = debounce(function(path, isDirectory, isSource) {
            if (isDirectory) {
                // ç«‹å³æ›´æ–°è·¯å¾„æ˜¾ç¤ºï¼Œæä¾›å³æ—¶åé¦ˆ
                if (isSource) {
                    currentSourcePath = path;
                    // ç›´æ¥å¼‚æ­¥æµè§ˆç›®å½•ï¼Œæ— åŠ è½½åŠ¨ç”»
                    browseSourceAsync();
                } else {
                    currentTargetPath = path;
                    // ç›´æ¥å¼‚æ­¥æµè§ˆç›®å½•ï¼Œæ— åŠ è½½åŠ¨ç”»
                    browseTargetAsync();
                }
            }
        }, DOUBLE_CLICK_CONFIG.debounceDelay); // ä½¿ç”¨é…ç½®çš„é˜²æŠ–å»¶è¿Ÿ

        // æ›´æ–°è·¯å¾„å¯¼èˆª
        function updatePathNavigation(currentPath, isSource) {
            const navId = isSource ? 'sourcePathNav' : 'targetPathNav';
            const displayId = isSource ? 'sourcePathDisplay' : 'targetPathDisplay';
            const nav = document.getElementById(navId);
            const display = document.getElementById(displayId);

            // å¦‚æœæ­£å¤„äºå†…è”ç¼–è¾‘æˆ–æäº¤ä¸­ï¼Œä¸è¦åˆ·æ–°ä»¥å…æ‰“æ–­è¾“å…¥/è§¦å‘ DOM ç§»é™¤é”™è¯¯
            if (display && display.dataset && (display.dataset.editing === 'true' || display.dataset.editing === 'committing')) {
                return;
            }

            const isWindows = currentPath && currentPath.includes(':');

            if (currentPath && currentPath !== '/') {
                nav.style.display = 'block';
                const parts = currentPath.split('/').filter(part => part);
                let html = '';

                if (isWindows) {
                    // Windowsè·¯å¾„å¯¼èˆªï¼šä»¥é©±åŠ¨å™¨ä¸ºæ ¹ï¼Œä¾‹å¦‚ C:/ï¼Œå¹¶åœ¨é©±åŠ¨å™¨å¤„æä¾›ä¸‹æ‹‰ç£ç›˜åˆ‡æ¢
                    const drive = parts[0]; // ä¾‹å¦‚ C:

                    // åŠ¨æ€æ„å»ºç£ç›˜ä¸‹æ‹‰ï¼ˆä»…å½“å·²æ‹¿åˆ°ç£ç›˜åˆ—è¡¨æ—¶æ‰å±•ç¤ºä¸‹æ‹‰ï¼›å¦åˆ™ä¿æŒæ™®é€šé“¾æ¥ï¼Œä¸æ˜¾ç¤ºä»»ä½•å ä½æ–‡æ¡ˆï¼‰
                    const drives = (isSource ? windowsDrivesSource : windowsDrivesTarget) || [];
                    if (drives.length > 0) {
                        const driveMenuItems = drives.map(d => {
                            const letterRaw = (d.letter || '').toUpperCase();
                            const letter = letterRaw.endsWith(':') ? letterRaw : (letterRaw + ':');
                            const iconHtml = d.type === 'network'
                                ? '<i class="bi bi-globe2 me-2 text-secondary"></i>'
                                : '<i class="bi bi-hdd-fill me-2 text-secondary"></i>';
                            const active = letter === drive.toUpperCase() ? ' active' : '';
                            return `<li><a class="dropdown-item${active}" href="#" onclick="switchWindowsDrive('${letter}', ${isSource}); return false;">${iconHtml}${d.name}</a></li>`;
                        }).join('');
                        html += `
                            <div class="dropdown d-inline-block">
                                <a href="#" class="path-segment dropdown-toggle" data-bs-toggle="dropdown" onclick="event.preventDefault();">${drive}/</a>
                                <ul class="dropdown-menu">${driveMenuItems}</ul>
                            </div>
                        `;
                    } else {
                        // æœªåŠ è½½ç£ç›˜åˆ—è¡¨ï¼šæ˜¾ç¤ºä¸ºæ™®é€šå¯ç‚¹å‡»è·¯å¾„æ®µï¼Œä¸å±•ç¤ºä»»ä½•â€œåŠ è½½ä¸­â€å­—æ ·
                        html += `<a href="#" class="path-segment" onclick="navigateToPath('${drive}/', ${isSource})">${drive}/</a>`;
                    }

                    let buildPath = drive;
                    // å…¶ä»–å­è·¯å¾„
                    parts.slice(1).forEach(part => {
                        buildPath += '/' + part;
                        html += '<span class="path-separator">/</span>';
                        html += `<a href="#" class="path-segment" onclick="navigateToPath('${buildPath}', ${isSource})">${part}</a>`;
                    });
                    display.innerHTML = html;
                } else {
                    // Linuxè·¯å¾„å¯¼èˆªï¼šä»¥/ä¸ºæ ¹
                    let buildPath = '';
                    html = '<a href="#" class="path-segment" onclick="navigateToPath(\'/\', ' + isSource + ')">æ ¹ç›®å½•</a>';
                    parts.forEach(part => {
                        buildPath += '/' + part;
                        html += '<span class="path-separator">/</span>';
                        html += `<a href="#" class="path-segment" onclick="navigateToPath('${buildPath}', ${isSource})">${part}</a>`;
                    });
                    display.innerHTML = html;
                }
            } else {
                nav.style.display = 'block';
                display.innerHTML = '<span class="path-segment">æ ¹ç›®å½•</span>';
            }

            // åŒæ­¥å½“å‰è·¯å¾„æ–‡æœ¬ï¼ˆç”¨äºå†…è”ç¼–è¾‘åˆå§‹å†…å®¹ï¼‰
            if (display) {
                display.dataset.currentPath = currentPath || '/';
            }
        }

        function maybeStartPathInlineEdit(event, isSource) {
            // ç‚¹å‡»è·¯å¾„ç©ºç™½åŒºåŸŸæ—¶è¿›å…¥å†…è”ç¼–è¾‘ï¼›é¿å…åœ¨æŒ‰é’®/é“¾æ¥ä¸Šè§¦å‘
            if (event.target.closest('button') || event.target.closest('a') || event.target.closest('.bi')) return;
            startPathInlineEdit(isSource);
        }

        function startPathInlineEdit(isSource) {
            const displayId = isSource ? 'sourcePathDisplay' : 'targetPathDisplay';
            const display = document.getElementById(displayId);
            if (!display) return;

            const currentPath = display.dataset.currentPath || (isSource ? currentSourcePath : currentTargetPath) || '/';
            display.dataset.editing = 'true';
            display.innerHTML = `<span class="path-inline-editor" contenteditable="true" spellcheck="false" onkeydown="handlePathInlineKey(event, ${isSource})" onblur="cancelPathInlineEdit(${isSource})">${currentPath}</span>`;

            const editor = display.querySelector('.path-inline-editor');
            if (editor) {
                setTimeout(() => selectAllText(editor), 0);
            }
        }

        function selectAllText(el) {
            try {
                const range = document.createRange();
                range.selectNodeContents(el);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            } catch (_) {}
        }

        function handlePathInlineKey(event, isSource) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const target = event.target;
                let path = (target.textContent || '').trim();
                if (!path) return;
                if (isWindowsPath(path)) {
                    path = path.replace(/\\+/g, '/');
                }
                const display = document.getElementById(isSource ? 'sourcePathDisplay' : 'targetPathDisplay');
                if (display) {
                    display.dataset.editing = 'committing';
                }
                navigateToPath(path, isSource);
                // ç­‰å¾…å½“å‰äº‹ä»¶æ ˆç»“æŸåå†åˆ·æ–°æ˜¾ç¤ºï¼Œé¿å… blur æœŸé—´çš„ DOM å†²çª
                setTimeout(() => {
                    if (display) {
                        display.dataset.editing = '';
                    }
                    updatePathNavigation(isSource ? currentSourcePath : currentTargetPath, isSource);
                }, 0);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                cancelPathInlineEdit(isSource);
            }
        }

        function cancelPathInlineEdit(isSource) {
            const display = document.getElementById(isSource ? 'sourcePathDisplay' : 'targetPathDisplay');
            if (display && display.dataset.editing === 'committing') {
                return;
            }
            if (display) display.dataset.editing = '';
            updatePathNavigation(isSource ? currentSourcePath : currentTargetPath, isSource);
        }

            // Windowsè·¯å¾„æ£€æµ‹
            function isWindowsPath(p) {
                return !!(p && p.includes(':'));
            }

            // è®¡ç®—çˆ¶çº§è·¯å¾„ï¼ˆå…¼å®¹Windowsä¸Linuxï¼‰
            function getParentPath(p) {
                if (!p) return '/';
                if (isWindowsPath(p)) {
                    const parts = p.split('/').filter(Boolean); // ä¾‹å¦‚: ['C:', 'Users', 'Alice']
                    if (parts.length <= 1) {
                        // å·²åœ¨é©±åŠ¨å™¨æ ¹ï¼Œæ¯”å¦‚ 'C:/'
                        return parts[0] + '/';
                    }
                    const parentParts = parts.slice(0, -1);
                    let parent = parentParts.join('/');
                    if (parentParts.length === 1) {
                        // ä¿æŒé©±åŠ¨å™¨æ ¹ä¸º 'C:/'
                        parent += '/';
                    }
                    return parent;
                }
                // Linux: æ™®é€šä¸Šçº§
                return p.split('/').slice(0, -1).join('/') || '/';
            }


        // åœ¨è·¯å¾„å¯¼èˆªä¸­åˆ‡æ¢Windowsç£ç›˜
        function switchWindowsDrive(letter, isSource) {
            const driveLetter = letter.endsWith(':') ? letter : (letter + ':');
            const drivePath = driveLetter + '/';
            if (isSource) {
                currentSourcePath = drivePath;
                browseSourceInstant(currentSourcePath);
                updatePathNavigation(currentSourcePath, true);
            } else {
                currentTargetPath = drivePath;
                browseTargetInstant(currentTargetPath);
                updatePathNavigation(currentTargetPath, false);
            }
        }


        // å¯¼èˆªåˆ°æŒ‡å®šè·¯å¾„ï¼ˆæ— åŠ è½½åŠ¨ç”»ç‰ˆæœ¬ï¼‰
        function navigateToPath(path, isSource) {
            if (isSource) {
                currentSourcePath = path;
                // ç›´æ¥ä½¿ç”¨å³æ—¶æµè§ˆï¼Œæ— åŠ è½½åŠ¨ç”»
                browseSourceInstant(path);
            } else {
                currentTargetPath = path;
                // ç›´æ¥ä½¿ç”¨å³æ—¶æµè§ˆï¼Œæ— åŠ è½½åŠ¨ç”»
                browseTargetInstant(path);
            }
        }

        // ç«‹å³é€‰æ‹©æ–‡ä»¶ï¼ˆæ— å»¶è¿Ÿè§†è§‰åé¦ˆï¼‰
        function selectFileImmediate(event, path, name, isDirectory, fileId, isSource) {
            event.stopPropagation();

            const fileElement = document.getElementById(fileId);
            if (!fileElement) return;

            const idx = Number(fileElement.dataset.idx || -1);

            if (event.shiftKey && (lastSelectedIndex[isSource ? 'source' : 'target'] !== null)) {
                const anchor = lastSelectedIndex[isSource ? 'source' : 'target'];
                selectRange(isSource, anchor, idx);
            } else if (event.ctrlKey || event.metaKey) {
                const arr = isSource ? selectedSourceFiles : selectedTargetFiles;
                if (fileElement.classList.contains('selected')) {
                    const newArr = arr.filter(f => f.path !== path);
                    if (isSource) selectedSourceFiles = newArr; else selectedTargetFiles = newArr;
                    fileElement.classList.remove('selected');
                } else {
                    arr.push({path, name, is_directory: isDirectory});
                    fileElement.classList.add('selected');
                }
                lastSelectedIndex[isSource ? 'source' : 'target'] = idx;
            } else {
                // å•é€‰ - ç«‹å³æ˜¾ç¤ºé€‰ä¸­çŠ¶æ€ï¼ˆå¹¶æ¸…ç©ºå¦ä¸€ä¾§é€‰æ‹©ï¼‰
                clearAllSelections();
                fileElement.classList.add('selected');
                if (isSource) {
                    selectedSourceFiles = [{path, name, is_directory: isDirectory}];
                } else {
                    selectedTargetFiles = [{path, name, is_directory: isDirectory}];
                }
                lastSelectedIndex[isSource ? 'source' : 'target'] = idx;
            }

            updateSelectionInfo();
        }

        // é€‰æ‹©æ–‡ä»¶ï¼ˆæ”¯æŒå¤šé€‰ï¼‰- ä¿ç•™åŸå‡½æ•°ä»¥å…¼å®¹å…¶ä»–è°ƒç”¨
        function selectFile(event, path, name, isDirectory, fileId) {
            // å…¼å®¹æ—§è°ƒç”¨ï¼šæ ¹æ® fileId æ¨æ–­å·¦å³é¢æ¿
            const isSource = fileId && fileId.indexOf('sourceFileBrowser') !== -1;
            selectFileImmediate(event, path, name, isDirectory, fileId, isSource);
        }

        function getFileNodes(isSource) {
            const containerId = isSource ? 'sourceFileBrowser' : 'targetFileBrowser';
            return Array.from(document.querySelectorAll(`#${containerId} .file-item.selectable`));
        }

        async function ensureAllItemsLoaded(isSource) {
            const state = isSource ? browseState.source : browseState.target;
            if (state.loadingAllPromise) {
                return state.loadingAllPromise;
            }
            const { serverSelect, showHiddenCheckbox } = getPanelConfig(isSource);
            const server = document.getElementById(serverSelect).value;
            const showHidden = document.getElementById(showHiddenCheckbox).checked;
            if (!server || !state.path) return state.fullItems || [];

            // å·²ç»å…¨éƒ¨åŠ è½½çš„å¿«é€Ÿè¿”å›
            const loadedCount = state.fullItems ? state.fullItems.length : 0;
            if (!state.hasMore && loadedCount >= (state.total || loadedCount)) {
                return state.fullItems || [];
            }

            state.loadingAllPromise = (async () => {
                let localOffset = loadedCount;
                while (true) {
                    const params = new URLSearchParams({
                        path: state.path,
                        show_hidden: showHidden,
                        offset: localOffset,
                        limit: BROWSE_PAGE_SIZE_MAX
                    });
                    const resp = await fetch(`/api/browse/${server}?${params.toString()}`, { cache: 'no-cache' });
                    const data = await resp.json();
                    if (!data.success) break;
                    const pageFiles = data.files || [];
                    state.fullItems = (state.fullItems || []).concat(pageFiles);
                    state.total = data.total_count || data.file_count || state.total || 0;
                    state.fullOffset = data.next_offset ?? (localOffset + pageFiles.length);
                    state.fullHasMore = data.has_more;
                    state.loadedCount = Math.max(state.loadedCount || 0, state.fullOffset || 0);
                    localOffset = state.fullOffset || (localOffset + pageFiles.length);
                    if (!data.has_more) break;
                }
                return state.fullItems || [];
            })();

            try {
                return await state.loadingAllPromise;
            } finally {
                state.loadingAllPromise = null;
            }
        }

        function renderAllItems(isSource, items) {
            const state = isSource ? browseState.source : browseState.target;
            const { containerId } = getPanelConfig(isSource);
            const path = getActivePath(isSource);
            const total = state.total || items.length;
            state.loadedCount = items.length;
            state.offset = items.length;
            state.hasMore = false;
            displayFiles(containerId, items, path, isSource, {
                append: false,
                totalCount: total,
                loadedCount: state.loadedCount,
                startIndex: 0
            });
            updateFileCountDisplay(isSource, state.loadedCount, total);
        }

        // æ¸…é™¤æ‰€æœ‰é€‰æ‹©
        function clearAllSelections() {
            selectedSourceFiles = [];
            selectedTargetFiles = [];
            document.querySelectorAll('.file-item.selected').forEach(item => {
                item.classList.remove('selected');
            });
            lastSelectedIndex.source = null;
            lastSelectedIndex.target = null;
        }

        function selectAll(isSource) {
            ensureAllItemsLoaded(isSource).then(allItems => {
                renderAllItems(isSource, allItems || []);
                const nodes = getFileNodes(isSource);
                nodes.forEach(node => node.classList.add('selected'));
                const selected = (allItems || []).map((f) => ({
                    path: f.path,
                    name: f.name,
                    is_directory: f.is_directory
                }));
                if (isSource) {
                    selectedSourceFiles = selected;
                    lastSelectedIndex.source = selected.length ? selected.length - 1 : null;
                } else {
                    selectedTargetFiles = selected;
                    lastSelectedIndex.target = selected.length ? selected.length - 1 : null;
                }
                updateSelectionInfo();
            });
        }

        // æ›´æ–°é€‰æ‹©ä¿¡æ¯
        function updateSelectionInfo() {
            if (selectedSourceFiles.length > 0 && selectedTargetFiles.length > 0) {
                addLogWarning('âš ï¸ å·¦å³ä¸¤ä¾§åŒæ—¶é€‰æ‹©äº†é¡¹ç›®ï¼Œè¯·åªåœ¨ä¸€ä¾§é€‰æ‹©ä»¥ç¡®å®šæ–¹å‘');
            }

            function renderSelectedInfo(isSource, selectedArr) {
                const el = document.getElementById(isSource ? 'sourceSelectedInfo' : 'targetSelectedInfo');
                if (!el) return;
                if (!selectedArr || selectedArr.length === 0) {
                    el.style.display = 'none';
                    el.textContent = '';
                    return;
                }
                const fileCount = selectedArr.filter(it => !it.is_directory).length;
                const dirCount = selectedArr.filter(it => it.is_directory).length;
                const parts = [];
                if (fileCount > 0) parts.push(`${fileCount} æ–‡ä»¶`);
                if (dirCount > 0) parts.push(`${dirCount} æ–‡ä»¶å¤¹`);
                el.textContent = `å·²é€‰ä¸­ï¼š${parts.join('ï¼Œ')}`;
                el.style.display = 'inline';
            }

            renderSelectedInfo(true, selectedSourceFiles);
            renderSelectedInfo(false, selectedTargetFiles);
        }

        // æ‹–æ‹½åŠŸèƒ½å·²ç§»é™¤ä»¥æå‡æ€§èƒ½
        // æ‹–æ‹½åŠŸèƒ½å·²ç§»é™¤ä»¥æå‡æ€§èƒ½

        function selectRange(isSource, startIdx, endIdx) {
            const nodes = getFileNodes(isSource);
            const min = Math.min(startIdx, endIdx);
            const max = Math.max(startIdx, endIdx);
            const selected = [];
            nodes.forEach(node => {
                const idx = Number(node.dataset.idx || -1);
                if (idx >= min && idx <= max) {
                    node.classList.add('selected');
                    selected.push({
                        path: node.dataset.path,
                        name: node.dataset.name,
                        is_directory: String(node.dataset.isDirectory).toLowerCase() === 'true'
                    });
                } else {
                    node.classList.remove('selected');
                }
            });
            if (isSource) {
                selectedSourceFiles = selected;
            } else {
                selectedTargetFiles = selected;
            }
        }

        // å¼€å§‹ä¼ è¾“ï¼ˆå•æŒ‰é’®ï¼šè‡ªåŠ¨åˆ¤æ–­æ–¹å‘ï¼‰
        function startTransfer() {
            const sourceServerLeft = document.getElementById('sourceServer').value;
            const targetServerRight = document.getElementById('targetServer').value;
            const leftSelected = selectedSourceFiles.length > 0;
            const rightSelected = selectedTargetFiles.length > 0;

            // è·å–ç”¨æˆ·é€‰æ‹©çš„ä¼ è¾“æ¨¡å¼
            const modeRadio = document.querySelector('input[name="transferMode"]:checked');
            const mode = modeRadio ? modeRadio.value : 'copy';
            currentTransferMode = mode;

            const fastSSH = true;
            const parallelTransfer = true;

            // å‰ªåˆ‡æ¨¡å¼å¼¹çª—æé†’
            if (currentTransferMode === 'move') {
                const ok = confirm('å½“å‰é€‰æ‹©çš„æ˜¯ã€Œå‰ªåˆ‡ã€æ¨¡å¼ï¼Œæºæ–‡ä»¶å°†è¢«åˆ é™¤ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ');
                if (!ok) {
                    return;
                }
            }

            // é€‰æ‹©æ ¡éªŒ
            if (leftSelected && rightSelected) {
                addLogWarning('âš ï¸ å·¦å³ä¸¤ä¾§åŒæ—¶é€‰æ‹©äº†é¡¹ç›®ï¼Œè¯·åªåœ¨ä¸€ä¾§é€‰æ‹©ä»¥ç¡®å®šä¼ è¾“æ–¹å‘');
                alert('å·¦å³ä¸¤ä¾§åŒæ—¶é€‰æ‹©äº†é¡¹ç›®ï¼Œè¯·åªåœ¨ä¸€ä¾§é€‰æ‹©ä»¥ç¡®å®šä¼ è¾“æ–¹å‘');
                return;
            }
            if (!leftSelected && !rightSelected) {
                addLogWarning('âš ï¸ è¯·é€‰æ‹©è¦ä¼ è¾“çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                alert('è¯·é€‰æ‹©è¦ä¼ è¾“çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                return;
            }

            // æŒ‰é€‰æ‹©è‡ªåŠ¨ç¡®å®šæ–¹å‘
            let sourceServer, targetServer, targetPath, sourceFiles;
            if (leftSelected) {
                // å·¦ -> å³
                sourceServer = sourceServerLeft;
                targetServer = targetServerRight;
                targetPath = currentTargetPath;
                sourceFiles = selectedSourceFiles;
                currentTransferDirection = 'ltr';
            } else {
                // å³ -> å·¦
                sourceServer = targetServerRight;
                targetServer = sourceServerLeft;
                targetPath = currentSourcePath;
                sourceFiles = selectedTargetFiles;
                currentTransferDirection = 'rtl';
            }

            // æœåŠ¡å™¨ä¸è·¯å¾„æ ¡éªŒ
            if (!sourceServer || !targetServer || !targetPath) {
                addLogWarning('âš ï¸ è¯·é€‰æ‹©æºæœåŠ¡å™¨ã€ç›®æ ‡æœåŠ¡å™¨å’Œç›®æ ‡è·¯å¾„');
                alert('è¯·é€‰æ‹©æºæœåŠ¡å™¨ã€ç›®æ ‡æœåŠ¡å™¨å’Œç›®æ ‡è·¯å¾„');
                return;
            }

            // åŒæœåŠ¡å™¨è·¯å¾„å†²çªæ ¡éªŒ
            if (sourceServer === targetServer) {
                const hasConflict = sourceFiles.some(file =>
                    file.path === targetPath || targetPath.startsWith(file.path + '/')
                );
                if (hasConflict) {
                    addLogWarning('âš ï¸ æºè·¯å¾„å’Œç›®æ ‡è·¯å¾„ä¸èƒ½ç›¸åŒæˆ–å­˜åœ¨åŒ…å«å…³ç³»');
                    alert('æºè·¯å¾„å’Œç›®æ ‡è·¯å¾„ä¸èƒ½ç›¸åŒæˆ–å­˜åœ¨åŒ…å«å…³ç³»');
                    return;
                }
            }

            // è®¾ç½®ä¼ è¾“çŠ¶æ€
            isTransferring = true;

            // æ˜¾ç¤ºè¿›åº¦é¢æ¿
            document.getElementById('progressContainer').style.display = 'block';
            const startBtn = document.getElementById('startTransferBtn');
            if (startBtn) startBtn.style.display = 'none';
            document.getElementById('cancelTransferBtn').style.display = 'inline-block';

            const fileNames = sourceFiles.map(f => f.name).join(', ');
            const modeText = mode === 'copy' ? 'å¤åˆ¶' : 'ç§»åŠ¨';
            const sshText = fastSSH ? '(SSHåŠ é€Ÿ)' : '';
            const parallelText = parallelTransfer ? '(ç«‹å³å¹¶è¡Œä¼ è¾“)' : '';



            addLogInfo(`ğŸ“¤ æº: ${sourceServer} (${sourceFiles.length}é¡¹)`);
            addLogInfo(`ğŸ“¥ ç›®æ ‡: ${targetServer}:${targetPath}`);
            addLogInfo(`ğŸ“‹ æ–‡ä»¶: ${fileNames.length > 50 ? fileNames.substring(0, 50) + '...' : fileNames}`);

            // å‘é€ä¼ è¾“è¯·æ±‚
            socket.emit('start_transfer', {
                source_server: sourceServer,
                source_files: sourceFiles,
                target_server: targetServer,
                target_path: targetPath,
                mode: mode,
                fast_ssh: fastSSH,
                parallel_transfer: parallelTransfer
            });
        }



        // å–æ¶ˆä¼ è¾“
        function cancelTransfer() {
            if (currentTransferId) {
                // ç«‹å³æ›´æ–°UIçŠ¶æ€ï¼Œä¸ç­‰å¾…ç¡®è®¤
                addLogWarning('ğŸ›‘ ç”¨æˆ·è¯·æ±‚å–æ¶ˆä¼ è¾“...');

                // ç«‹å³ç¦ç”¨å–æ¶ˆæŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
                const cancelBtn = document.getElementById('cancelTransferBtn');
                cancelBtn.disabled = true;
                cancelBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> å–æ¶ˆä¸­...';

                // ç«‹å³å‘é€å–æ¶ˆè¯·æ±‚ï¼Œä¸éœ€è¦ç¡®è®¤å¯¹è¯æ¡†
                socket.emit('cancel_transfer', {
                    transfer_id: currentTransferId
                });

                // è®¾ç½®è¶…æ—¶ä¿æŠ¤ï¼Œå¦‚æœ3ç§’å†…æ²¡æœ‰æ”¶åˆ°å“åº”ï¼Œå¼ºåˆ¶é‡ç½®UI
                setTimeout(() => {
                    if (cancelBtn.disabled) {
                        addLogWarning('âš ï¸ å–æ¶ˆæ“ä½œè¶…æ—¶ï¼Œå¼ºåˆ¶é‡ç½®ç•Œé¢');
                        resetTransferUI();
                        isTransferring = false;
                    }
                }, 3000);
            }
        }

        // å¼ºåˆ¶å–æ¶ˆä¼ è¾“ï¼ˆåŒå‡»è§¦å‘ï¼‰
        function forceCancelTransfer() {
            if (currentTransferId) {
                addLogError('ğŸš¨ å¼ºåˆ¶ç»ˆæ­¢ä¼ è¾“...');

                // ç«‹å³é‡ç½®UI
                resetTransferUI();
                isTransferring = false;

                // å‘é€å¼ºåˆ¶å–æ¶ˆè¯·æ±‚
                socket.emit('cancel_transfer', {
                    transfer_id: currentTransferId,
                    force: true
                });

                // æ¸…é™¤å½“å‰ä¼ è¾“ID
                currentTransferId = null;
            }
        }

        // é‡ç½®ä¼ è¾“ç•Œé¢
        function resetTransferUI() {
            const pc = document.getElementById('progressContainer');
            if (pc) pc.style.display = 'none';
            const startBtn = document.getElementById('startTransferBtn');
            if (startBtn) startBtn.style.display = 'inline-block';

            // é‡ç½®å–æ¶ˆæŒ‰é’®
            const cancelBtn = document.getElementById('cancelTransferBtn');
            if (cancelBtn) {
                cancelBtn.style.display = 'none';
                cancelBtn.disabled = false;
                cancelBtn.innerHTML = '<i class="bi bi-stop-circle-fill"></i> å–æ¶ˆ';
            }

            // é‡ç½®ä¼ è¾“è·¯å¾„æ˜¾ç¤º
            const routeEl0 = document.getElementById('transferRoute');
            if (routeEl0) routeEl0.innerHTML = '<i class="bi bi-arrow-right-circle-fill me-1"></i>å‡†å¤‡ä¼ è¾“...';

            // é‡ç½®çŠ¶æ€ä¿¡æ¯
            { const el = document.getElementById('transferStatus'); if (el) el.textContent = 'å‡†å¤‡ä¸­'; }
            { const el = document.getElementById('transferSpeed'); if (el) el.textContent = '-'; }
            { const el = document.getElementById('transferredBytes'); if (el) el.textContent = '-'; }
            { const el = document.getElementById('eta'); if (el) el.textContent = '-'; }

            transferRefreshOverride = null;
            currentTransferId = null;
        }

        // WebSocketäº‹ä»¶å¤„ç†
        socket.on('transfer_started', function(data) {
            isTransferring = true;
            currentTransferId = data.transfer_id;
            window.transferModeLogged = false; // é‡ç½®ä¼ è¾“æ¨¡å¼æ—¥å¿—æ ‡å¿—
            { const el = document.getElementById('transferStatus'); if (el) el.textContent = 'ä¼ è¾“ä¸­...'; }

        });

        // è¿›åº¦æ›´æ–°äº‹ä»¶å·²ç§»é™¤ä»¥æå‡æ€§èƒ½ - åªåœ¨ä¼ è¾“å®Œæˆæ—¶æ›´æ–°çŠ¶æ€

        socket.on('transfer_log', function(data) {
            if (data.transfer_id === currentTransferId) {
                const msg = data.message || '';
                const keep = msg.startsWith('ğŸ“¤ æº:') || msg.startsWith('ğŸ“¥ ç›®æ ‡:') || msg.startsWith('ğŸ“‹ æ–‡ä»¶:') || msg.startsWith('âŒ') || (msg.includes('âœ…') && (msg.includes('ä¼ è¾“å®Œæˆ') || msg.includes('å®Œæˆ')));
                if (keep) {
                    if (msg.includes('âœ…')) {
                        addLogSuccess(msg);
                    } else if (msg.startsWith('âŒ')) {
                        addLogError(msg);
                    } else {
                        addLogInfo(msg);
                    }
                }
            }
        });

        // ç›‘å¬é€Ÿåº¦æ›´æ–°äº‹ä»¶ï¼ˆ10msé«˜é¢‘æ›´æ–°ï¼‰
        socket.on('speed_update', function(data) {
            if (data.transfer_id === currentTransferId) {
                // æ›´æ–°ä¼ è¾“é€Ÿåº¦ï¼ˆæ¯10msï¼‰
                if (data.speed) {
                    const el = document.getElementById('transferSpeed');
                    if (el) el.textContent = data.speed;
                }

                // æ›´æ–°å·²ç”¨æ—¶é—´ï¼ˆä»…å½“æœ‰æ–°æ—¶é—´æ•°æ®æ—¶ï¼‰
                if (data.elapsed_time) {
                    const el = document.getElementById('elapsedTime');
                    if (el) el.textContent = data.elapsed_time;
                }

                // æ›´æ–°ä¼ è¾“è·¯å¾„æ˜¾ç¤ºï¼ˆä»…åœ¨é¦–æ¬¡æˆ–å˜åŒ–æ—¶ï¼‰
                if (data.source_server && data.target_server) {
                    const sourceDisplay = data.source_server === 'localhost' ? 'æœ¬åœ°' : data.source_server;
                    const targetDisplay = data.target_server === 'localhost' ? 'æœ¬åœ°' : data.target_server;

                    let routeIcon = 'ğŸ”„';
                    if (data.transfer_mode === 'local_to_remote') {
                        routeIcon = 'ğŸ“¤';
                    } else if (data.transfer_mode === 'remote_to_local') {
                        routeIcon = 'ğŸ“¥';
                    }

                    const newRoute = `${routeIcon} ${sourceDisplay} â†’ ${targetDisplay}`;
                    const routeEl = document.getElementById('transferRoute');
                    if (routeEl) {
                        const currentRoute = routeEl.innerHTML;
                        // åªåœ¨è·¯å¾„å˜åŒ–æ—¶æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„DOMæ“ä½œ
                        if (currentRoute !== newRoute) {
                            routeEl.innerHTML = newRoute;
                        }
                    }
                }
            }
        });

        socket.on('run_output', function(data) {
            const runId = data.run_id || 'run';
            const msg = data.message || '';
            const isError = data.is_error === true;
            const isFinal = data.final === true;
            const exitCode = typeof data.exit_code === 'number' ? data.exit_code : null;
            appendRunLog(runId, msg, isError, isFinal, exitCode);
            if (isFinal && currentRunId === runId) {
                currentRunId = null;
                updateRunControls();
            }
        });

        socket.on('transfer_complete', function(data) {
            if (data.transfer_id === currentTransferId) {
                // ä¼ è¾“ç»“æŸï¼Œæ¢å¤æ—¥å¿—è®°å½•
                isTransferring = false;

                const refreshOverride = transferRefreshOverride;
                transferRefreshOverride = null;

                if (data.status === 'success') {
                    { const el = document.getElementById('transferStatus'); if (el) el.textContent = 'ä¼ è¾“å®Œæˆ'; }
                    { const el = document.getElementById('transferRoute'); if (el) el.innerHTML = '<i class="bi bi-check-circle-fill text-success me-1"></i>ä¼ è¾“å®Œæˆ'; }

                    // æ˜¾ç¤ºæ€»è€—æ—¶ï¼ˆå•ä½ï¼šæ—¶:åˆ†:ç§’ï¼‰ï¼Œå°† HH:MM:SS è½¬æˆ 00æ—¶:00åˆ†:00ç§’ æ ¼å¼
                    if (data.total_time) {
                        let formattedTime = data.total_time;
                        const parts = String(data.total_time).split(':');
                        if (parts.length === 3) {
                            const [h, m, s] = parts;
                            formattedTime = `${h}æ—¶:${m}åˆ†:${s}ç§’`;
                        }
                        addLogSuccess(`âœ… ä¼ è¾“å·²å®Œæˆ - æ€»è€—æ—¶: ${formattedTime}`);
                        const el = document.getElementById('elapsedTime');
                        if (el) el.textContent = formattedTime;
                    } else {
                        addLogSuccess('âœ… ä¼ è¾“å·²å®Œæˆ');
                    }

                    // æ ¹æ®æ–¹å‘è‡ªåŠ¨åˆ·æ–°å¯¹åº”ç›®å½•ï¼Œæ˜¾ç¤ºæœ€æ–°ä¼ è¾“çš„æ–‡ä»¶
                    setTimeout(() => {
                        const isMoveMode = (currentTransferMode === 'move');

                        if (refreshOverride && (refreshOverride.refreshSource || refreshOverride.refreshTarget)) {
                            if (refreshOverride.refreshSource) {
                                const sourceServer = document.getElementById('sourceServer').value;
                                if (sourceServer && currentSourcePath) {
                                    refreshSourceAsync();
                                }
                            }
                            if (refreshOverride.refreshTarget) {
                                const targetServer = document.getElementById('targetServer').value;
                                if (targetServer && currentTargetPath) {
                                    refreshTargetAsync();
                                }
                            }
                            return;
                        }

                        if (currentTransferDirection === 'ltr') {
                            const targetServer = document.getElementById('targetServer').value;
                            if (targetServer && currentTargetPath) {
                                refreshTargetAsync();
                            }
                            // å‰ªåˆ‡æ¨¡å¼ä¸‹ï¼Œæºä¾§æ–‡ä»¶è¢«åˆ é™¤ï¼Œä¹Ÿéœ€è¦ç«‹åˆ»åˆ·æ–°æºç›®å½•
                            if (isMoveMode) {
                                const sourceServer = document.getElementById('sourceServer').value;
                                if (sourceServer && currentSourcePath) {
                                    refreshSourceAsync();
                                }
                            }
                        } else {
                            const sourceServer = document.getElementById('sourceServer').value;
                            if (sourceServer && currentSourcePath) {
                                refreshSourceAsync();
                            }
                            // å‰ªåˆ‡æ¨¡å¼ä¸‹ï¼Œç›®æ ‡ä¾§æ–°å¢æ–‡ä»¶ï¼Œä¹Ÿéœ€è¦åˆ·æ–°ç›®æ ‡ç›®å½•
                            if (isMoveMode) {
                                const targetServer = document.getElementById('targetServer').value;
                                if (targetServer && currentTargetPath) {
                                    refreshTargetAsync();
                                }
                            }
                        }
                    }, 100);
                } else if (data.status === 'partial_success') {
                    // ğŸ”§ BUGä¿®å¤ï¼šå¤„ç†éƒ¨åˆ†æˆåŠŸçŠ¶æ€
                    { const el = document.getElementById('transferStatus'); if (el) el.textContent = 'ä¼ è¾“éƒ¨åˆ†å®Œæˆ'; }
                    { const el = document.getElementById('transferRoute'); if (el) el.innerHTML = '<i class="bi bi-exclamation-triangle-fill text-warning me-1"></i>éƒ¨åˆ†æˆåŠŸ'; }
                    { const pb = document.getElementById('progressBar'); if (pb) pb.classList.add('bg-warning'); }

                    // æ˜¾ç¤ºæ€»è€—æ—¶
                    if (data.total_time) {
                        const el = document.getElementById('elapsedTime');
                        if (el) el.textContent = data.total_time;
                    }

                        if (data.total_time) {
                            addLogWarning(`ğŸ”¶ ä¼ è¾“éƒ¨åˆ†å®Œæˆ - æ€»è€—æ—¶: ${data.total_time}`);
                        } else {
                            addLogWarning('ğŸ”¶ ä¼ è¾“éƒ¨åˆ†å®Œæˆï¼ˆå­˜åœ¨å¤±è´¥é¡¹ç›®ï¼‰');
                        }
                        if (data.message) {
                            addLogWarning(`è¯¦æƒ…: ${data.message}`);
                        }


                    // éƒ¨åˆ†æˆåŠŸä¹Ÿåˆ·æ–°å¯¹åº”ç›®å½•ï¼ˆå‰ªåˆ‡æ¨¡å¼ä¸‹åŒæ ·éœ€è¦åˆ·æ–°ä¸¤ä¾§ï¼Œä¿è¯åˆ é™¤/æ–°å¢éƒ½å¯è§ï¼‰
                    setTimeout(() => {
                        const isMoveMode = (currentTransferMode === 'move');

                        if (refreshOverride && (refreshOverride.refreshSource || refreshOverride.refreshTarget)) {
                            if (refreshOverride.refreshSource) {
                                const sourceServer = document.getElementById('sourceServer').value;
                                if (sourceServer && currentSourcePath) {
                                    refreshSourceAsync();
                                }
                            }
                            if (refreshOverride.refreshTarget) {
                                const targetServer = document.getElementById('targetServer').value;
                                if (targetServer && currentTargetPath) {
                                    refreshTargetAsync();
                                }
                            }
                            return;
                        }

                        if (currentTransferDirection === 'ltr') {
                            const targetServer = document.getElementById('targetServer').value;
                            if (targetServer && currentTargetPath) {
                                refreshTargetAsync();
                            }
                            if (isMoveMode) {
                                const sourceServer = document.getElementById('sourceServer').value;
                                if (sourceServer && currentSourcePath) {
                                    refreshSourceAsync();
                                }
                            }
                        } else {
                            const sourceServer = document.getElementById('sourceServer').value;
                            if (sourceServer && currentSourcePath) {
                                refreshSourceAsync();
                            }
                            if (isMoveMode) {
                                const targetServer = document.getElementById('targetServer').value;
                                if (targetServer && currentTargetPath) {
                                    refreshTargetAsync();
                                }
                            }
                        }
                    }, 1000);
                } else {
                    // å®Œå…¨å¤±è´¥
                    { const el = document.getElementById('transferStatus'); if (el) el.textContent = 'ä¼ è¾“å¤±è´¥'; }
                    { const pb = document.getElementById('progressBar'); if (pb) pb.classList.add('bg-danger'); }
                    addLogError(`âŒ ä¼ è¾“å¤±è´¥: ${data.message}`);
                }

                // å°†UIé‡ç½®å»¶è¿Ÿä»3ç§’ç¼©çŸ­ä¸º800msï¼Œä½¿ç»“æŸæ›´â€œä¸æ»‘â€
                setTimeout(resetTransferUI, 100);
            }
        });

        // å¤„ç†å–æ¶ˆä¼ è¾“å“åº”
        socket.on('transfer_cancelled', function(data) {
            if (data.transfer_id === currentTransferId) {
                // ä¼ è¾“å–æ¶ˆï¼Œæ¢å¤æ—¥å¿—è®°å½•
                isTransferring = false;
                transferRefreshOverride = null;

                if (data.status === 'success') {
                    { const el = document.getElementById('transferStatus'); if (el) el.textContent = 'ä¼ è¾“å·²å–æ¶ˆ'; }
                    { const pb = document.getElementById('progressBar'); if (pb) { pb.classList.remove('progress-bar-animated'); pb.classList.add('bg-warning'); } }
                    addLogWarning('âš ï¸ ä¼ è¾“å·²å–æ¶ˆ');
                } else {
                    addLogError(`âŒ å–æ¶ˆä¼ è¾“å¤±è´¥: ${data.message}`);
                }

                setTimeout(resetTransferUI, 2000);
            }
        });

        // åˆå§‹åŒ–é¢æ¿è°ƒæ•´åŠŸèƒ½
        function initializeResizers() {
            // å›ºå®šå·¦å³é¢æ¿å®½åº¦ï¼Œå¹¶ç¦ç”¨æ‹–æ‹½è°ƒæ•´
            const verticalResizer = document.getElementById('verticalResizer');
            const sourcePanel = document.getElementById('sourcePanel');
            const targetPanel = document.getElementById('targetPanel');

            if (sourcePanel) {
                sourcePanel.style.flexBasis = '50%';
                sourcePanel.style.width = '50%';
            }
            if (targetPanel) {
                targetPanel.style.flexBasis = '50%';
                targetPanel.style.width = '50%';
            }
            if (verticalResizer) {
                verticalResizer.style.pointerEvents = 'none';
                verticalResizer.style.cursor = 'default';
            }
        }

        // æ ¹æ®æœåŠ¡å™¨IPè·å–é»˜è®¤è·¯å¾„ï¼ˆä½¿ç”¨åç«¯ä¼ å…¥çš„ servers æ•°æ®ï¼‰
        function getDefaultPath(serverIP) {
            const meta = SERVERS_DATA && SERVERS_DATA[serverIP];
            if (meta && meta.default_path) return meta.default_path;
            return '';
        }

        function getRememberedPath(serverIP, isSource) {
            const panel = isSource ? 'source' : 'target';
            const rec = (REMEMBERED_PATHS && REMEMBERED_PATHS[panel]) || null;
            if (rec && rec.server === serverIP && rec.path) {
                return rec.path;
            }
            return null;
        }

        function getDefaultPathWithRemember(serverIP, isSource) {
            const rem = getRememberedPath(serverIP, isSource);
            if (rem) return rem;
            return getDefaultPath(serverIP);
        }

        function updateRememberedCache(panel, server, path) {
            if (!panel || !server || !path) return;
            if (typeof REMEMBERED_PATHS !== 'object' || REMEMBERED_PATHS === null) return;
            REMEMBERED_PATHS[panel] = { server, path };
        }

        function applyRememberedSelections() {
            if (!REMEMBERED_PATHS || Object.keys(REMEMBERED_PATHS).length === 0) return;

            const applyOne = (panelKey, selectId) => {
                const selectEl = document.getElementById(selectId);
                const rec = REMEMBERED_PATHS && REMEMBERED_PATHS[panelKey];
                if (!selectEl || !rec || !rec.server || !rec.path) return false;
                const hasOption = Array.from(selectEl.options || []).some(opt => opt.value === rec.server);
                if (!hasOption) return false;
                selectEl.value = rec.server;
                // è§¦å‘ç°æœ‰é€»è¾‘ï¼ˆä¼šä¼˜å…ˆä½¿ç”¨è®°å¿†çš„è·¯å¾„ï¼‰
                selectEl.dispatchEvent(new Event('change'));
                return true;
            };

            const sourceApplied = applyOne('source', 'sourceServer');
            const targetApplied = applyOne('target', 'targetServer');
            if (sourceApplied || targetApplied) {
                addLogInfo('ğŸ§­ å·²è‡ªåŠ¨æ¢å¤ä¸Šæ¬¡ä½¿ç”¨çš„æœåŠ¡å™¨å’Œè·¯å¾„');
            }
        }

        // æ£€æŸ¥æ˜¯å¦ä¸ºWindowsæœåŠ¡å™¨ï¼ˆä½¿ç”¨æ¨¡æ¿å†…ç½®æ•°æ®ï¼Œé¿å…é¢å¤–ç½‘ç»œè¯·æ±‚ï¼‰
        function isWindowsServer(serverIP) {
            try {
                return SERVERS_DATA[serverIP] && SERVERS_DATA[serverIP].os_type === 'windows';
            } catch (error) {
                console.error('æ£€æŸ¥æœåŠ¡å™¨ç±»å‹å¤±è´¥:', error);
                return false;
            }
        }

        // åŠ è½½Windowsç£ç›˜åˆ—è¡¨ï¼ˆå­˜å…¥å†…å­˜ï¼Œä¾›è·¯å¾„å¯¼èˆªä¸‹æ‹‰ä½¿ç”¨ï¼‰
        async function loadWindowsDrives(serverIP, isSource) {
            try {
                const response = await fetch(`/api/windows_drives/${serverIP}`);
                const data = await response.json();

                const normalizeDrive = (letter) => {
                    if (!letter) return null;
                    const upper = String(letter).toUpperCase();
                    return upper.endsWith(':') ? upper : `${upper}:`;
                };

                if (data.success && data.drives) {
                    if (isSource) {
                        windowsDrivesSource = data.drives;
                    } else {
                        windowsDrivesTarget = data.drives;
                    }

                    const desiredPath = isSource ? currentSourcePath : currentTargetPath;
                    const desiredDrive = normalizeDrive((desiredPath || '').split(/[\\/]/)[0]);

                    const preferred = data.drives.find(d => normalizeDrive(d.letter) === desiredDrive) ||
                        data.drives.find(d => normalizeDrive(d.letter) === 'C:') ||
                        data.drives[0];

                    if (preferred) {
                        const driveLabel = normalizeDrive(preferred.letter);
                        const driveRoot = driveLabel ? `${driveLabel}/` : '/';
                        const useDesiredPath = Boolean(desiredDrive && driveLabel === desiredDrive && desiredPath);
                        const targetPath = useDesiredPath ? desiredPath : driveRoot;

                        if (isSource) {
                            if (currentSourcePath !== targetPath) {
                                currentSourcePath = targetPath;
                                browseSourceInstant(currentSourcePath);
                            }
                            updatePathNavigation(currentSourcePath, true);
                        } else {
                            if (currentTargetPath !== targetPath) {
                                currentTargetPath = targetPath;
                                browseTargetInstant(currentTargetPath);
                            }
                            updatePathNavigation(currentTargetPath, false);
                        }
                        if (!useDesiredPath) {
                            addLogInfo(`ğŸ’¾ é»˜è®¤é€‰æ‹©ç£ç›˜: ${preferred.letter}`);
                        }
                    }

                    addLogInfo(`ğŸ’¾ å·²åŠ è½½Windowsç£ç›˜åˆ—è¡¨: ${data.drives.length}ä¸ªç£ç›˜`);
                } else {
                    console.error('åŠ è½½ç£ç›˜åˆ—è¡¨å¤±è´¥:', data.error);
                }
            } catch (error) {
                console.error('åŠ è½½Windowsç£ç›˜åˆ—è¡¨å¼‚å¸¸:', error);
            }
        }

        // å…¼å®¹ä¿ç•™ï¼šè‹¥æ—§é€‰æ‹©å™¨ä¸å­˜åœ¨åˆ™ä»€ä¹ˆä¹Ÿä¸åš
        function hideWindowsDriveSelector(isSource) {
            const el = document.getElementById(isSource ? 'sourceDriveSelector' : 'targetDriveSelector');
            if (el) el.style.display = 'none';
        }

        // LOGOæ˜¾ç¤ºæ–¹æ¡ˆåˆ‡æ¢å‡½æ•°ï¼ˆä¿ç•™å¤‡ç”¨ï¼‰
        function switchLogoDisplay(mode) {
            // å½“å‰ä½¿ç”¨æ–¹æ¡ˆä¸€ï¼ˆæ ‡é¢˜å¹¶æ’ï¼‰ï¼Œå…¶ä»–æ–¹æ¡ˆå·²éšè—
            console.log(`LOGOæ˜¾ç¤ºæ¨¡å¼: ${mode === 'header' ? 'æ ‡é¢˜å¹¶æ’ï¼ˆå½“å‰ï¼‰' : mode}`);
        }


            // è½»é‡çº§å›¾ç‰‡é¢„è§ˆä¸åœ¨çº¿ç¼–è¾‘ï¼ˆæ‡’åŠ è½½ã€å¼‚æ­¥ã€æ€§èƒ½ä¼˜å…ˆï¼‰
            // æ³¨æ„ï¼šé¢„è§ˆç¼“å­˜ä¸€å®šè¦æ”¯æŒå¤±æ•ˆ/æ¸…ç†ï¼Œå¦åˆ™â€œåŒè·¯å¾„æ–‡ä»¶è¢«åˆ é™¤åé‡å»º/è¦†ç›–â€ä¼šå¯¼è‡´å‰ç«¯ä¸€ç›´æ˜¾ç¤ºæ—§å†…å®¹ï¼ˆåªèƒ½æ•´é¡µåˆ·æ–°æ‰èƒ½æ¸…ç©ºå†…å­˜ç¼“å­˜ï¼‰ã€‚
            const PreviewCache = new Map(); // key -> { type: 'blob'|'text', value: string, ts: number }

            function normalizePreviewPath(path) {
                return String(path || '').replace(/\\/g, '/');
            }

            function getPreviewKey(server, path) {
                return `${server}|${normalizePreviewPath(path)}`;
            }

            function revokePreviewEntry(entry) {
                if (!entry) return;
                if (entry.type === 'blob' && typeof entry.value === 'string' && entry.value.startsWith('blob:')) {
                    try { URL.revokeObjectURL(entry.value); } catch (_) {}
                }
            }

            function previewCacheGet(server, path, type) {
                const key = getPreviewKey(server, path);
                const entry = PreviewCache.get(key);
                if (!entry) return null;
                if (type && entry.type !== type) return null;
                return entry;
            }

            function previewCacheSet(server, path, type, value) {
                const key = getPreviewKey(server, path);
                const prev = PreviewCache.get(key);
                if (prev && prev.type === 'blob' && prev.value !== value) {
                    revokePreviewEntry(prev);
                }
                PreviewCache.set(key, { type, value, ts: Date.now() });
            }

            function invalidatePreviewCache(server, paths) {
                if (!server || !Array.isArray(paths) || paths.length === 0) return;
                const normalized = paths.map(normalizePreviewPath).filter(Boolean);
                if (normalized.length === 0) return;

                const serverPrefix = `${server}|`;
                const exact = new Set(normalized);
                const prefixes = normalized.map(p => (p.endsWith('/') ? p : p + '/'));

                const keysToDelete = [];
                for (const key of PreviewCache.keys()) {
                    if (!key.startsWith(serverPrefix)) continue;
                    const cachedPath = key.slice(serverPrefix.length);
                    if (exact.has(cachedPath) || prefixes.some(prefix => cachedPath.startsWith(prefix))) {
                        keysToDelete.push(key);
                    }
                }
                keysToDelete.forEach((k) => {
                    const entry = PreviewCache.get(k);
                    revokePreviewEntry(entry);
                    PreviewCache.delete(k);
                });
            }

            function invalidatePreviewCacheUnderDir(server, dirPath) {
                if (!server || !dirPath) return;
                invalidatePreviewCache(server, [dirPath]);
            }
            const ImageViewer = {
                items: [],
                index: -1,
                server: '',
                isSource: true
            };

        async function getImageBlobUrl(server, path) {
            const cached = previewCacheGet(server, path, 'blob');
            if (cached) return cached.value;

            const url = `/api/image/stream?server=${encodeURIComponent(server)}&path=${encodeURIComponent(path)}`;
            const resp = await fetch(url, { cache: 'no-store' });
            if (!resp.ok) {
                let msg = '';
                try { msg = await resp.text(); } catch (_) {}
                throw new Error(`HTTP ${resp.status}${msg ? ': ' + msg : ''}`);
            }
            const blob = await resp.blob();
            const blobUrl = URL.createObjectURL(blob);
            previewCacheSet(server, path, 'blob', blobUrl);
            return blobUrl;
        }

        function isImageFile(name) {
            return /\.(jpg|jpeg|png|gif|bmp|webp|svg)$/i.test(name);
        }
        function isTextEditable(name) {
            return /\.(txt|xml|py|js|css|html?|json|md|log|conf|ini|yml|yaml|sh|c|cpp|h|hpp)$/i.test(name);
        }
        function isArchiveFile(name) {
            return /\.(zip|tar|tar\.gz|tgz|tar\.bz2|tar\.xz)$/i.test(name);
        }

            function buildImageViewer(server, path, name, isSource) {
                const state = isSource ? browseState.source : browseState.target;
                const allItems = state.fullItems && state.fullItems.length ? state.fullItems : [];
                const imgs = [];
                let currentIndex = -1;
                allItems.forEach((it, idx) => {
                    if (!it || it.is_directory) return;
                    if (!isImageFile(it.name)) return;
                    if (it.name === name && it.path === path) {
                        currentIndex = imgs.length;
                    }
                    imgs.push({ path: it.path, name: it.name });
                });
                ImageViewer.items = imgs;
                ImageViewer.index = currentIndex >= 0 ? currentIndex : 0;
                ImageViewer.server = server;
                ImageViewer.isSource = isSource;
            }

            function applyImageTransform(img) {
                if (!img) return;
                img.style.transform = `translate(${imageOffsetX}px, ${imageOffsetY}px) scale(${imageZoom})`;
            }

            async function showImageAt(index) {
                if (!ImageViewer.items || ImageViewer.items.length === 0) return;
                const len = ImageViewer.items.length;
                if (len === 0) return;
                if (index < 0) index = len - 1;
                if (index >= len) index = 0;
                ImageViewer.index = index;
                const item = ImageViewer.items[index];
                const server = ImageViewer.server;

                // ç«‹å³æ˜¾ç¤ºæ¨¡æ€æ¡†ï¼Œé¿å…ç­‰å¾…æ„Ÿ
                const modal = document.getElementById('imagePreviewModal');
                const img = modal.querySelector('img');
                if (modal && img) {
                    modal.style.display = 'block';
                    img.style.opacity = '0.3';
                    img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2Y1ZjVmNSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5Loading...</dGV4dD48L3N2Zz4=';
                    imageZoom = 1;
                    imageOffsetX = 0;
                    imageOffsetY = 0;
                    applyImageTransform(img);
                }

                try {
                    const blobUrl = await getImageBlobUrl(server, item.path);

                    // å›¾ç‰‡åŠ è½½å®Œæˆåæ˜¾ç¤º
                    if (img) {
                        img.onload = () => { img.style.opacity = '1'; };
                        img.src = blobUrl;
                    }
                    const caption = document.getElementById('imagePreviewCaption');
                    if (caption) {
                        caption.textContent = `${item.name} (${index + 1}/${len})`;
                    }
                } catch (e) {
                    addLogError('å›¾ç‰‡é¢„è§ˆå¤±è´¥: ' + (e.message || e));
                    console.error('Image preview fetch error:', e);
                    closeImageModal();
                }
            }

            async function previewImage(server, path, name, isSource) {
                try {
                    const state = isSource ? browseState.source : browseState.target;
                    if (!state.fullItems || state.fullHasMore) {
                        await ensureAllItemsLoaded(isSource);
                    }
                    buildImageViewer(server, path, name, isSource);
                    await showImageAt(ImageViewer.index);
                } catch (e) {
                    addLogError('å›¾ç‰‡é¢„è§ˆå¤±è´¥: ' + (e.message || e));
                    console.error('Image preview fetch error:', e);
                    closeImageModal();
                }
            }

            async function editTextFile(server, path, name) {
                try {
                    // ç«‹å³æ‰“å¼€ç¼–è¾‘å™¨ï¼Œæå‡æ„ŸçŸ¥é€Ÿåº¦
                    const cached = previewCacheGet(server, path, 'text');
                    openEditorModal(server, path, name, cached ? cached.value : 'æ­£åœ¨åŠ è½½...');
                    if (cached) return;

                    // å¼‚æ­¥æ‹‰å–å†…å®¹
                    const url = `/api/file/read?server=${encodeURIComponent(server)}&path=${encodeURIComponent(path)}`;
                    const resp = await fetch(url, { cache: 'no-store' });
                    if (!resp.ok) {
                        let msg = '';
                        try { msg = await resp.text(); } catch(_) {}
                        throw new Error(`HTTP ${resp.status}${msg ? ': ' + msg : ''}`);
                    }
                    const data = await resp.json();
                    if (!data.success) throw new Error(data.error || 'è¯»å–å¤±è´¥');
                    const content = data.content || '';
                    previewCacheSet(server, path, 'text', content);

                    // å¡«å……å†…å®¹
                    const ta = document.querySelector('#editorModal textarea');
                    if (ta) ta.value = content;
                } catch (e) {
                    addLogError('æ‰“å¼€ç¼–è¾‘å™¨å¤±è´¥: ' + (e.message || e));
                    // å¤±è´¥æ—¶å…³é—­ç¼–è¾‘å™¨ï¼Œé¿å…ç©ºç™½çŠ¶æ€
                    closeEditorModal();
                }
            }

            function handleFileItemDblClick(el, isSource) {
                try {
                    const path = el.dataset.path;
                    const name = el.dataset.name || '';
                    const isDir = String(el.dataset.isDirectory).toLowerCase() === 'true';
                    if (isDir) {
                        // ç›®å½•çš„åŒå‡»å¯¼èˆªä»ç”±åŸæœ‰é€»è¾‘å¤„ç†ï¼Œè¿™é‡Œä¸å¹²é¢„
                        return;
                    }
                    const server = (isSource ? document.getElementById('sourceServer') : document.getElementById('targetServer')).value;
                    if (!server) return;
                    if (isImageFile(name)) {
                        previewImage(server, path, name, isSource);
                    } else if (isTextEditable(name)) {
                        editTextFile(server, path, name);
                    }
                } catch (e) {
                    console.error('handleFileItemDblClick error:', e);
                }
            }

            function openImageModal(src, title) {
                const modal = document.getElementById('imagePreviewModal');
                if (!modal) return;
                const img = modal.querySelector('img');
                if (img) img.src = src;
                modal.style.display = 'block';
            }
            function closeImageModal() {
                const modal = document.getElementById('imagePreviewModal');
                if (!modal) return;
                modal.style.display = 'none';
                const img = modal.querySelector('img');
                if (img) img.removeAttribute('src');
                imageZoom = 1;
                imageOffsetX = 0;
                imageOffsetY = 0;
                const caption = document.getElementById('imagePreviewCaption');
                if (caption) caption.textContent = '';
                ImageViewer.items = [];
                ImageViewer.index = -1;
	            }

		            let imageGridObserver = null;
		            const IMAGE_GRID_COLS_DEFAULT = 8;
		            const IMAGE_GRID_COLS_OPTIONS = [4, 6, 8, 10, 12];
		            let imageGridCols = IMAGE_GRID_COLS_DEFAULT;
		            let imageGridColsControlsBound = false;
		            let imageGridColsRaf = 0;
		            const IMAGE_GRID_MAX_PARALLEL = 4;
		            const imageGridLoadQueue = [];
		            let imageGridLoadingCount = 0;

		            function normalizeImageGridCols(value) {
		                const n = Number.parseInt(value, 10);
		                if (!Number.isFinite(n)) return IMAGE_GRID_COLS_DEFAULT;
		                return IMAGE_GRID_COLS_OPTIONS.includes(n) ? n : IMAGE_GRID_COLS_DEFAULT;
	            }

		            function applyImageGridColumns(cols) {
		                const normalized = normalizeImageGridCols(cols);
		                imageGridCols = normalized;

		                const btnWrap = document.getElementById('imageGridColsButtons');
		                if (btnWrap) {
		                    btnWrap.querySelectorAll('.image-grid-cols-btn').forEach(btn => {
		                        const btnCols = normalizeImageGridCols(btn.dataset.cols);
		                        btn.classList.toggle('active', btnCols === normalized);
		                    });
		                }

		                const container = document.getElementById('imageGridContainer');
		                if (!container) return;
		                if (imageGridColsRaf) {
		                    try { cancelAnimationFrame(imageGridColsRaf); } catch (_) {}
		                }
		                imageGridColsRaf = requestAnimationFrame(() => {
		                    container.style.setProperty('--image-grid-cols', String(normalized));
		                    imageGridColsRaf = 0;
		                });
		            }

	            function ensureImageGridColsControls() {
	                if (imageGridColsControlsBound) return;
	                const btnWrap = document.getElementById('imageGridColsButtons');
	                if (!btnWrap) return;

	                btnWrap.addEventListener('click', (e) => {
	                    const btn = e.target.closest('.image-grid-cols-btn[data-cols]');
	                    if (!btn) return;
	                    applyImageGridColumns(btn.dataset.cols);
	                });
	                imageGridColsControlsBound = true;

	                const initialBtn = btnWrap.querySelector('.image-grid-cols-btn.active[data-cols]');
		                const initialCols = initialBtn ? initialBtn.dataset.cols : IMAGE_GRID_COLS_DEFAULT;
		                applyImageGridColumns(initialCols);
		            }

		            function processImageGridQueue() {
		                if (imageGridLoadingCount >= IMAGE_GRID_MAX_PARALLEL) return;
		                const task = imageGridLoadQueue.shift();
		                if (!task) return;
		                imageGridLoadingCount++;
		                getImageBlobUrl(task.server, task.path)
		                    .then(url => {
		                        if (task.imgEl && task.imgEl.dataset.loaded !== '1') {
		                            task.imgEl.src = url;
		                            task.imgEl.dataset.loaded = '1';
		                        }
		                    })
		                    .catch(err => {
		                        if (task.imgEl) {
		                            task.imgEl.alt = 'åŠ è½½å¤±è´¥';
		                            task.imgEl.title = err.message || String(err);
		                            task.imgEl.dataset.loaded = 'err';
		                        }
		                    })
		                    .finally(() => {
		                        imageGridLoadingCount = Math.max(0, imageGridLoadingCount - 1);
		                        requestAnimationFrame(processImageGridQueue);
		                    });
		            }

		            function scheduleImageGridLoad(card) {
		                const imgEl = card.querySelector('img');
		                if (!imgEl || imgEl.dataset.loaded === '1' || imgEl.dataset.loading === '1') return;
		                imgEl.dataset.loading = '1';
		                imageGridLoadQueue.push({
		                    server: card.dataset.server,
		                    path: card.dataset.path,
		                    imgEl
		                });
		                processImageGridQueue();
		            }

	            function initImageGridObserver(rootEl) {
	                if (imageGridObserver) imageGridObserver.disconnect();
	                if (!('IntersectionObserver' in window)) {
	                    imageGridObserver = null;
                    return;
                }
	                imageGridObserver = new IntersectionObserver((entries) => {
	                    entries.forEach(entry => {
	                        if (!entry.isIntersecting) return;
	                        const card = entry.target;
	                        scheduleImageGridLoad(card);
	                        imageGridObserver && imageGridObserver.unobserve(card);
	                    });
	                }, {
	                    root: rootEl || null,
	                    rootMargin: '120px',
	                    threshold: 0.01
	                });
	            }

	            function loadImageCardImmediately(card) {
	                scheduleImageGridLoad(card);
	            }

            async function openImageGrid(isSource) {
                const serverSelectId = isSource ? 'sourceServer' : 'targetServer';
                const server = document.getElementById(serverSelectId)?.value;
                const state = isSource ? browseState.source : browseState.target;
                if (!server) {
                    addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æœåŠ¡å™¨');
                    return;
                }
                if (!state.path) {
                    addLogWarning('âš ï¸ è¯·å…ˆè¿›å…¥ä¸€ä¸ªç›®å½•');
                    return;
                }

	                const modal = document.getElementById('imageGridModal');
	                const container = document.getElementById('imageGridContainer');
	                if (!modal || !container) return;
	                ensureImageGridColsControls();
	                applyImageGridColumns(imageGridCols);
	                modal.style.display = 'block';
	                document.body.style.overflow = 'hidden';
	                container.innerHTML = '<div class="image-grid-empty">åŠ è½½ä¸­...</div>';
	                initImageGridObserver(modal);

                const renderBatch = (items, server) => {
                    const frag = document.createDocumentFragment();
                    for (const item of items) {
                        const card = document.createElement('div');
                        card.className = 'image-grid-card';
                        card.dataset.server = server;
                        card.dataset.path = item.path;

                        const imgEl = document.createElement('img');
                        imgEl.alt = item.name;
                        imgEl.loading = 'lazy';
                        imgEl.dataset.loaded = '0';

                        const nameEl = document.createElement('div');
                        nameEl.className = 'image-grid-name';
                        nameEl.textContent = item.name;

                        card.appendChild(imgEl);
                        card.appendChild(nameEl);
                        card.addEventListener('click', () => {
                            previewImage(server, item.path, item.name, isSource);
                        });

                        frag.appendChild(card);
                        if (imageGridObserver) {
                            imageGridObserver.observe(card);
                        } else {
                            loadImageCardImmediately(card);
                        }
                    }
                    container.appendChild(frag);
                };

                const appendImagesChunked = (images, server, chunkSize = 60) => {
                    container.innerHTML = '';
                    let idx = 0;
                    const step = () => {
                        const slice = images.slice(idx, idx + chunkSize);
                        renderBatch(slice, server);
                        idx += chunkSize;
                        if (idx < images.length) {
                            requestAnimationFrame(step);
                        }
                    };
                    step();
                };

                const ensureAndRender = async () => {
                    try {
                        const initial = (state.fullItems || []).filter(it => it && !it.is_directory && isImageFile(it.name));
                        if (initial.length) {
                            appendImagesChunked(initial, server);
                        } else {
                            container.innerHTML = '<div class="image-grid-empty">åŠ è½½ä¸­...</div>';
                        }

                        // å¢é‡æ‹‰å–å‰©ä½™åˆ†é¡µï¼Œè¾¹æ‹‰è¾¹æ¸²æŸ“
                        if (state.hasMore || state.fullHasMore || !state.fullItems) {
                            let localOffset = state.fullOffset || state.loadedCount || (state.offset || 0);
                            while (true) {
                                const params = new URLSearchParams({
                                    path: state.path,
                                    show_hidden: document.getElementById(isSource ? 'sourceShowHidden' : 'targetShowHidden').checked,
                                    offset: localOffset,
                                    limit: BROWSE_PAGE_SIZE_MAX
                                });
                                const resp = await fetch(`/api/browse/${server}?${params.toString()}`, { cache: 'no-cache' });
                                const data = await resp.json();
                                if (!data.success) break;
                                const pageFiles = (data.files || []).filter(it => it && !it.is_directory && isImageFile(it.name));
                                if (pageFiles.length) {
                                    if (!container.innerHTML || container.innerHTML.includes('åŠ è½½ä¸­')) {
                                        container.innerHTML = '';
                                    }
                                    renderBatch(pageFiles, server);
                                }
                                state.fullItems = (state.fullItems || []).concat(data.files || []);
                                state.total = data.total_count || data.file_count || state.total || 0;
                                state.fullOffset = data.next_offset ?? (localOffset + (data.files || []).length);
                                state.fullHasMore = data.has_more;
                                state.loadedCount = Math.max(state.loadedCount || 0, state.fullOffset || 0);
                                localOffset = state.fullOffset || localOffset + (data.files || []).length;
                                if (!data.has_more) break;
                            }
                        }

                        const imgs = (state.fullItems || []).filter(it => it && !it.is_directory && isImageFile(it.name));
                        if (!imgs.length) {
                            container.innerHTML = '<div class="image-grid-empty">å½“å‰ç›®å½•æ²¡æœ‰å›¾ç‰‡</div>';
                        } else {
                            addLogInfo(`ğŸ–¼ï¸ å·²å±•å¼€ ${imgs.length} å¼ å›¾ç‰‡`);
                        }
                    } catch (e) {
                        container.innerHTML = `<div class="image-grid-empty">åŠ è½½å¤±è´¥: ${escapeHtml(e.message || e)}</div>`;
                        addLogError('âŒ å›¾ç‰‡ç½‘æ ¼åŠ è½½å¤±è´¥: ' + (e.message || e));
                    }
                };

                ensureAndRender();
            }

            function closeImageGrid() {
	                const modal = document.getElementById('imageGridModal');
	                const container = document.getElementById('imageGridContainer');
	                if (modal) modal.style.display = 'none';
	                if (container) container.innerHTML = '';
	                document.body.style.overflow = '';
	                if (imageGridObserver) {
	                    imageGridObserver.disconnect();
	                }
	                imageGridLoadQueue.length = 0;
	                imageGridLoadingCount = 0;
	            }

            function openEditorModal(server, path, title, content) {
                const modal = document.getElementById('editorModal');
                modal.querySelector('.modal-title').textContent = title;
                const ta = modal.querySelector('#editorTextarea');
                ta.value = content;
                ta.dataset.server = server;
                ta.dataset.path = path;
                const findInput = document.getElementById('findInput');
                const replaceInput = document.getElementById('replaceInput');
                if (findInput) findInput.value = '';
                if (replaceInput) replaceInput.value = '';
                const countEl = document.getElementById('findCount');
                if (countEl) countEl.textContent = '';
                syncMinimap();
                renderFindHighlights();
                modal.style.display = 'block';
                hideFindReplace();
                ta.focus();
            }

            function compareFromSelection() {
                const srcServer = document.getElementById('sourceServer').value;
                const tgtServer = document.getElementById('targetServer').value;
                const leftSelection = selectedSourceFiles.filter(f => !f.is_directory).map(f => ({ ...f, server: srcServer }));
                const rightSelection = selectedTargetFiles.filter(f => !f.is_directory).map(f => ({ ...f, server: tgtServer }));
                const all = [...leftSelection, ...rightSelection];
                if (all.length !== 2) {
                    addLogWarning('âš ï¸ è¯·æŒ‰Ctrlé€‰ä¸­ä¸¤ä¸ªæ–‡ä»¶åå†ç‚¹å‡»å¯¹æ¯”ï¼ˆå¯è·¨æœåŠ¡å™¨ï¼‰');
                    return;
                }
                if (!all[0].server || !all[1].server) {
                    addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©å·¦å³æœåŠ¡å™¨');
                    return;
                }
                const [a, b] = all;
                const extA = (a.name.lastIndexOf('.') >= 0) ? a.name.slice(a.name.lastIndexOf('.')).toLowerCase() : '';
                const extB = (b.name.lastIndexOf('.') >= 0) ? b.name.slice(b.name.lastIndexOf('.')).toLowerCase() : '';
                if (extA !== extB) {
                    addLogWarning('âš ï¸ ä»…æ”¯æŒç›¸åŒç±»å‹çš„æ–‡ä»¶è¿›è¡Œå¯¹æ¯”');
                    return;
                }
                performCompare(
                    { server: a.server, path: a.path, name: a.name, ext: extA },
                    { server: b.server, path: b.path, name: b.name, ext: extB }
                );
            }

            async function performCompare(left, right) {
                try {
                    addLogInfo(`ğŸ§ æ­£åœ¨å¯¹æ¯”ï¼š${left.name} â‡† ${right.name}`);
                    const resp = await fetch('/api/compare_files', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            server_a: left.server,
                            path_a: left.path,
                            server_b: right.server,
                            path_b: right.path
                        })
                    });
                    const data = await resp.json();
                    if (!data.success) {
                        addLogError(`âŒ å¯¹æ¯”å¤±è´¥: ${data.error || 'æœªçŸ¥é”™è¯¯'}`);
                        return;
                    }
                    showDiffModal(data.lines || [], left, right);
                } catch (e) {
                    addLogError(`âŒ å¯¹æ¯”å¼‚å¸¸: ${e.message || e}`);
                }
            }

            function showDiffModal(lines, leftMeta, rightMeta) {
                const modal = document.getElementById('diffModal');
                const rows = document.getElementById('diffRows');
                const leftPath = document.getElementById('diffLeftPath');
                const rightPath = document.getElementById('diffRightPath');
                const summary = document.getElementById('diffSummary');
                if (!modal || !rows) return;

                rows.innerHTML = '';
                leftPath.textContent = leftMeta ? `${leftMeta.name} (${leftMeta.server})` : '';
                rightPath.textContent = rightMeta ? `${rightMeta.name} (${rightMeta.server})` : '';

                let addCount = 0, delCount = 0, repCount = 0;
                (lines || []).forEach(line => {
                    const tag = line.tag || 'equal';
                    if (tag === 'insert') addCount++;
                    else if (tag === 'delete') delCount++;
                    else if (tag === 'replace') repCount++;

                    const pair = document.createElement('div');
                    pair.className = 'diff-line';
                    pair.classList.add(tag);

                    const leftSide = document.createElement('div');
                    leftSide.className = 'diff-side left';
                    const lno = document.createElement('div');
                    lno.className = 'diff-lineno';
                    lno.textContent = line.left_no ? line.left_no : '';
                    const lcode = document.createElement('div');
                    lcode.className = 'diff-code';
                    lcode.textContent = (line.left ?? '');
                    leftSide.appendChild(lno);
                    leftSide.appendChild(lcode);

                    const rightSide = document.createElement('div');
                    rightSide.className = 'diff-side right';
                    const rno = document.createElement('div');
                    rno.className = 'diff-lineno';
                    rno.textContent = line.right_no ? line.right_no : '';
                    const rcode = document.createElement('div');
                    rcode.className = 'diff-code';
                    rcode.textContent = (line.right ?? '');
                    rightSide.appendChild(rno);
                    rightSide.appendChild(rcode);

                    pair.appendChild(leftSide);
                    pair.appendChild(rightSide);
                    rows.appendChild(pair);
                });

                if (summary) {
                    summary.textContent = `æ–°å¢ ${addCount}ï¼Œåˆ é™¤ ${delCount}ï¼Œä¿®æ”¹ ${repCount}`;
                }

                modal.style.display = 'block';
                document.body.style.overflow = 'hidden';
            }

            function closeDiffModal() {
                const modal = document.getElementById('diffModal');
                const rows = document.getElementById('diffRows');
                if (modal) modal.style.display = 'none';
                if (rows) rows.innerHTML = '';
                document.body.style.overflow = '';
            }

            function setupImageWheelZoom() {
                const modal = document.getElementById('imagePreviewModal');
                const img = modal ? modal.querySelector('img') : null;
                if (!modal || !img) return;
                let dragging = false;
                let startX = 0;
                let startY = 0;
                let lastX = 0;
                let lastY = 0;
                let rafPending = false;

                modal.addEventListener('wheel', (e) => {
                    if (modal.style.display === 'none') return;
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    imageZoom = Math.min(5, Math.max(0.2, imageZoom + delta));
                    applyImageTransform(img);
                }, { passive: false });

                modal.addEventListener('mousedown', (e) => {
                    if (modal.style.display === 'none') return;
                    if (e.target.closest('#imagePreviewCloseBtn')) return;
                    dragging = true;
                    startX = e.clientX - imageOffsetX;
                    startY = e.clientY - imageOffsetY;
                    lastX = imageOffsetX;
                    lastY = imageOffsetY;
                    e.preventDefault();
                });

                modal.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    lastX = e.clientX - startX;
                    lastY = e.clientY - startY;
                    if (!rafPending) {
                        rafPending = true;
                        requestAnimationFrame(() => {
                            imageOffsetX = lastX;
                            imageOffsetY = lastY;
                            applyImageTransform(img);
                            rafPending = false;
                        });
                    }
                });

                ['mouseup', 'mouseleave'].forEach(ev => {
                    modal.addEventListener(ev, () => { dragging = false; });
                });
            }
            function closeEditorModal() {
                document.getElementById('editorModal').style.display = 'none';
            }
            async function saveEditorContent() {
                const ta = document.querySelector('#editorModal textarea');
                const server = ta.dataset.server;
                const path = ta.dataset.path;
                const content = ta.value;
                const resp = await fetch('/api/file/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ server, path, content })
                });

            // ç»‘å®šå…³é—­æŒ‰é’®ï¼ˆé¿å…æŸäº›ç¯å¢ƒä¸‹å†…è”onclickä¸è§¦å‘ï¼‰
            document.addEventListener('DOMContentLoaded', () => {
                const btn = document.getElementById('imagePreviewCloseBtn');
                if (btn) btn.addEventListener('click', closeImageModal, { passive: true });
                const prevBtn = document.getElementById('imagePrevBtn');
                const nextBtn = document.getElementById('imageNextBtn');
                if (prevBtn) prevBtn.addEventListener('click', () => showImageAt(ImageViewer.index - 1));
                if (nextBtn) nextBtn.addEventListener('click', () => showImageAt(ImageViewer.index + 1));

                const ta = document.getElementById('editorTextarea');
                if (ta) {
                    ta.addEventListener('input', renderFindHighlights);
                    ta.addEventListener('scroll', renderFindHighlights);
                    renderFindHighlights();
                }

        document.addEventListener('keydown', (e) => {
            const modalVisible = document.getElementById('editorModal') && document.getElementById('editorModal').style.display !== 'none';
            if (!modalVisible) return;
            if (document.activeElement && document.activeElement.id === 'editorTextarea' && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a') {
                // è®© textarea è‡ªå·±å¤„ç†å…¨é€‰
                return;
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
                e.preventDefault();
                showFindReplace(false);
            } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'h') {
                e.preventDefault();
                        showFindReplace(true);
                    }
                });
            });

                const data = await resp.json();
                if (data.success) {
                    addLogInfo('ğŸ’¾ å·²ä¿å­˜: ' + path);
                    // æ›´æ–°ç¼“å­˜
                    previewCacheSet(server, path, 'text', content);
                    closeEditorModal();
                } else {
                    addLogError('ä¿å­˜å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                }
            }

            function syncMinimap() {
                // minimap å·²ç§»é™¤ï¼Œç•™ç©ºå‡½æ•°é˜²æ­¢å¼•ç”¨é”™è¯¯
            }

            function syncMinimapHighlight() {
                // minimap å·²ç§»é™¤ï¼Œç•™ç©ºå‡½æ•°é˜²æ­¢å¼•ç”¨é”™è¯¯
            }

            function renderFindHighlights() {
                const layer = document.getElementById('editorHighlightLayer');
                const ta = document.getElementById('editorTextarea');
                const findInput = document.getElementById('findInput');
                const query = findInput ? findInput.value : '';
                const countEl = document.getElementById('findCount');
                if (!layer || !ta) return;
                const text = ta.value || '';
                if (!query) {
                    layer.innerHTML = escapeHtml(text);
                    if (countEl) countEl.textContent = '';
                    return;
                }
                const safeQuery = query.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');
                const regex = new RegExp(safeQuery, 'g');
                let matchCount = 0;
                text.replace(regex, () => { matchCount++; return ''; });
                layer.innerHTML = escapeHtml(text);
                if (countEl) {
                    countEl.textContent = matchCount > 0 ? `${matchCount} æ¡` : '0 æ¡';
                }
            }

            // æŸ¥æ‰¾/æ›¿æ¢
            function showFindReplace(withReplace) {
                const bar = document.getElementById('findReplaceBar');
                const findInput = document.getElementById('findInput');
                const replaceInput = document.getElementById('replaceInput');
                const replaceBtn = document.getElementById('replaceBtn');
                const replaceAllBtn = document.getElementById('replaceAllBtn');
                if (!bar) return;
                bar.style.display = 'flex';
                if (withReplace) {
                    replaceInput.style.display = 'inline-block';
                    replaceBtn.style.display = 'inline-block';
                    replaceAllBtn.style.display = 'inline-block';
                } else {
                    replaceInput.style.display = 'none';
                    replaceBtn.style.display = 'none';
                    replaceAllBtn.style.display = 'none';
                }
                setTimeout(() => findInput && findInput.focus(), 0);
            }

            function hideFindReplace() {
                const bar = document.getElementById('findReplaceBar');
                const findInput = document.getElementById('findInput');
                const replaceInput = document.getElementById('replaceInput');
                const countEl = document.getElementById('findCount');
                if (findInput) findInput.value = '';
                if (replaceInput) replaceInput.value = '';
                if (countEl) countEl.textContent = '';
                renderFindHighlights();
                if (bar) bar.style.display = 'none';
            }

            function findNext() {
                const ta = document.getElementById('editorTextarea');
                const query = document.getElementById('findInput').value;
                renderFindHighlights();
                if (!ta || !query) return;
                const start = ta.selectionEnd;
                const idx = ta.value.indexOf(query, start);
                if (idx !== -1) {
                    ta.focus();
                    ta.setSelectionRange(idx, idx + query.length);
                    scrollToSelectionCenter();
                    return;
                }
                // å¾ªç¯æŸ¥æ‰¾
                const wrapIdx = ta.value.indexOf(query, 0);
                if (wrapIdx !== -1) {
                    ta.focus();
                    ta.setSelectionRange(wrapIdx, wrapIdx + query.length);
                    scrollToSelectionCenter();
                }
            }

            function findPrev() {
                const ta = document.getElementById('editorTextarea');
                const query = document.getElementById('findInput').value;
                renderFindHighlights();
                if (!ta || !query) return;
                const start = ta.selectionStart - 1;
                const idx = ta.value.lastIndexOf(query, start);
                if (idx !== -1) {
                    ta.focus();
                    ta.setSelectionRange(idx, idx + query.length);
                    scrollToSelectionCenter();
                    return;
                }
                const wrapIdx = ta.value.lastIndexOf(query);
                if (wrapIdx !== -1) {
                    ta.focus();
                    ta.setSelectionRange(wrapIdx, wrapIdx + query.length);
                    scrollToSelectionCenter();
                }
            }

            function scrollToSelectionCenter() {
                const ta = document.getElementById('editorTextarea');
                if (!ta) return;
                const selStart = ta.selectionStart || 0;
                const beforeText = ta.value.slice(0, selStart);
                const lines = beforeText.split('\n');
                const lineHeight = parseFloat(getComputedStyle(ta).lineHeight || '16');
                const targetTop = (lines.length - 1) * lineHeight;
                const centerOffset = ta.clientHeight / 2;
                ta.scrollTop = Math.max(0, targetTop - centerOffset);
            }

            function replaceOne() {
                const ta = document.getElementById('editorTextarea');
                const query = document.getElementById('findInput').value;
                const replacement = document.getElementById('replaceInput').value;
                if (!ta || !query) return;
                const selText = ta.value.substring(ta.selectionStart, ta.selectionEnd);
                if (selText === query) {
                    const before = ta.value.substring(0, ta.selectionStart);
                    const after = ta.value.substring(ta.selectionEnd);
                    const pos = before.length + replacement.length;
                    ta.value = before + replacement + after;
                    ta.setSelectionRange(pos - replacement.length, pos);
                    syncMinimap();
                }
                findNext();
                renderFindHighlights();
            }

            function replaceAll() {
                const ta = document.getElementById('editorTextarea');
                const query = document.getElementById('findInput').value;
                const replacement = document.getElementById('replaceInput').value;
                if (!ta || !query) return;
                ta.value = ta.value.split(query).join(replacement);
                syncMinimap();
                renderFindHighlights();
            }
            // é”®ç›˜ESCå…³é—­
        document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeImageModal();
                    closeEditorModal();
                    closeDiffModal();
                }
                const modal = document.getElementById('imagePreviewModal');
                const visible = modal && modal.style.display !== 'none';
                if (visible && ImageViewer.items.length > 0) {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        showImageAt(ImageViewer.index - 1);
                    } else if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        showImageAt(ImageViewer.index + 1);
                    }
                }

                if (e.key === 'Delete') {
                    if (_isEditableElement(e.target)) return;
                    const activePanel = document.activeElement && document.activeElement.closest && document.activeElement.closest('.file-browser');
                    let isSource = true;
                    if (activePanel && activePanel.id === 'targetFileBrowser') {
                        isSource = false;
                    } else if (activePanel && activePanel.id === 'sourceFileBrowser') {
                        isSource = true;
                    } else {
                        isSource = lastActivePanel !== 'target';
                    }
                    const selected = isSource ? selectedSourceFiles : selectedTargetFiles;
                    if (selected && selected.length) {
                        e.preventDefault();
                        deleteSelected(isSource ? 'source' : 'target');
                    }
                }

                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a') {
                    e.preventDefault();
                    // æ ¹æ®ç„¦ç‚¹ä¾§å…¨é€‰ï¼Œé»˜è®¤å·¦ä¾§
                    const activePanel = document.activeElement && document.activeElement.closest && document.activeElement.closest('.file-browser');
                    if (activePanel && activePanel.id === 'targetFileBrowser') {
                        selectAll(false);
                    } else if (activePanel && activePanel.id === 'sourceFileBrowser') {
                        selectAll(true);
                    } else {
                        // æ— ç„¦ç‚¹æ—¶æŒ‰æœ€è¿‘æ“ä½œçš„é¢æ¿
                        if (lastActivePanel === 'target') {
                            selectAll(false);
                        } else {
                            selectAll(true);
                        }
                    }
                }
            });

        // å³é”®èœå•ï¼šWindows é£æ ¼èœå•ï¼Œé€‰æ‹©é‡å‘½å/æ–°å»ºæ–‡ä»¶å¤¹
        function bindContextMenus() {
            const sourceContainer = document.getElementById('sourceFileBrowser');
            const targetContainer = document.getElementById('targetFileBrowser');
            const contextMenu = document.getElementById('fileContextMenu');
            const renameAction = contextMenu ? contextMenu.querySelector('[data-action="rename"]') : null;
            const newFileAction = contextMenu ? contextMenu.querySelector('[data-action="new-file"]') : null;
            const newFolderAction = contextMenu ? contextMenu.querySelector('[data-action="new-folder"]') : null;
            const runAction = contextMenu ? contextMenu.querySelector('[data-action="run"]') : null;
            const compareAction = contextMenu ? contextMenu.querySelector('[data-action="compare"]') : null;
            const sizeAction = contextMenu ? contextMenu.querySelector('[data-action="size"]') : null;
            const compressAction = contextMenu ? contextMenu.querySelector('[data-action="compress"]') : null;
            const extractAction = contextMenu ? contextMenu.querySelector('[data-action="extract"]') : null;
            const downloadWindowsAction = contextMenu ? contextMenu.querySelector('[data-action="download-windows"]') : null;
            let contextState = { isSource: true, targetRow: null };

            function hideContextMenu() {
                if (!contextMenu) return;
                contextMenu.style.display = 'none';
                contextMenu.dataset.visible = 'false';
            }

            function selectRowForContext(row, isSource) {
                if (!row) return;
                const alreadySelected = row.classList.contains('selected');

                if (alreadySelected) {
                    lastActivePanel = isSource ? 'source' : 'target';
                    updateSelectionInfo();
                    return;
                }

                // å³é”®æœªé€‰ä¸­çš„æ–‡ä»¶ï¼šä¸æ¸…ç©ºå·²æœ‰é€‰æ‹©ï¼Œç›´æ¥è¿½åŠ ï¼Œä¾¿äºè·¨é¢æ¿å¯¹æ¯”
                row.classList.add('selected');
                const item = {
                    path: row.dataset.path,
                    name: row.dataset.name,
                    is_directory: String(row.dataset.isDirectory).toLowerCase() === 'true'
                };
                if (isSource) {
                    if (!selectedSourceFiles.find(f => f.path === item.path)) {
                        selectedSourceFiles.push(item);
                    }
                    lastSelectedIndex.source = Number(row.dataset.idx || 0);
                } else {
                    if (!selectedTargetFiles.find(f => f.path === item.path)) {
                        selectedTargetFiles.push(item);
                    }
                    lastSelectedIndex.target = Number(row.dataset.idx || 0);
                }
                lastActivePanel = isSource ? 'source' : 'target';
                updateSelectionInfo();
            }

            function startInlineRename(row, isSource) {
                if (!row || row.dataset.editing === 'true') return;
                const nameSpan = row.querySelector('.file-name');
                if (!nameSpan) return;
                const original = nameSpan.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = original;
                input.className = 'form-control form-control-sm';
                input.style.width = '100%';
                input.style.padding = '1px 4px';
                input.style.height = '22px';
                input.style.fontSize = '0.9rem';
                input.style.display = 'inline-block';
                input.style.boxSizing = 'border-box';
                row.dataset.editing = 'true';
                nameSpan.replaceWith(input);
                input.focus();
                input.select();

                const cleanup = () => {
                    if (row.dataset.editing !== 'true') return;
                    const span = document.createElement('span');
                    span.className = 'file-name';
                    span.textContent = original;
                    input.replaceWith(span);
                    row.dataset.editing = 'false';
                };

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const newName = input.value.trim();
                        if (!newName || newName === original) {
                            cleanup();
                            return;
                        }
                        const server = document.getElementById(isSource ? 'sourceServer' : 'targetServer').value;
                        const path = row.dataset.path;
                        renameFile(isSource ? 'source' : 'target', server, path, newName);
                        cleanup();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cleanup();
                    }
                });

                ['mousedown', 'click'].forEach(ev => input.addEventListener(ev, (e) => e.stopPropagation()));
                input.addEventListener('blur', cleanup);
            }

            function startInlineCreate(isSource) {
                const { containerId } = getPanelConfig(isSource);
                const container = document.getElementById(containerId);
                const server = document.getElementById(isSource ? 'sourceServer' : 'targetServer').value;
                const currentPath = getActivePath(isSource);
                if (!container || !server || !currentPath) return;

                // è‹¥å·²å­˜åœ¨ä¸´æ—¶è¡Œï¼Œå…ˆç§»é™¤
                const existing = container.querySelector('.file-item.temp-new');
                if (existing) existing.remove();

                const row = document.createElement('div');
                row.className = 'file-item selectable temp-new';
                row.innerHTML = `
                    <i class="bi bi-folder-plus text-warning"></i>
                    <div class="file-info">
                        <input class="form-control form-control-sm" type="text" placeholder="æ–°å»ºæ–‡ä»¶å¤¹" style="width: 100%; padding: 1px 4px; height: 22px; font-size: 0.9rem; box-sizing: border-box; display: inline-block;" />
                    </div>
                `;
                const backRow = container.querySelector('.file-item[title*="è¿”å›"]');
                if (backRow && backRow.nextSibling) {
                    container.insertBefore(row, backRow.nextSibling);
                } else {
                    container.insertBefore(row, container.firstChild);
                }

                const input = row.querySelector('input');
                if (input) {
                    input.focus();
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const name = input.value.trim();
                            if (!name) {
                                row.remove();
                                return;
                            }
                            createFolder(isSource ? 'source' : 'target', server, currentPath, name);
                            row.remove();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            row.remove();
                        }
                    });
                    input.addEventListener('blur', () => row.remove());
                }
            }

            function startInlineCreateFile(isSource) {
                const { containerId } = getPanelConfig(isSource);
                const container = document.getElementById(containerId);
                const server = document.getElementById(isSource ? 'sourceServer' : 'targetServer').value;
                const currentPath = getActivePath(isSource);
                if (!container || !server || !currentPath) return;

                const existing = container.querySelector('.file-item.temp-new-file');
                if (existing) existing.remove();

                const row = document.createElement('div');
                row.className = 'file-item selectable temp-new-file';
                row.innerHTML = `
                    <i class="bi bi-file-earmark-plus text-primary"></i>
                    <div class="file-info">
                        <input class="form-control form-control-sm" type="text" placeholder="æ–°å»ºæ–‡ä»¶" style="width: 100%; padding: 1px 4px; height: 22px; font-size: 0.9rem; box-sizing: border-box; display: inline-block;" />
                    </div>
                `;
                const backRow = container.querySelector('.file-item[title*="è¿”å›"]');
                if (backRow && backRow.nextSibling) {
                    container.insertBefore(row, backRow.nextSibling);
                } else {
                    container.insertBefore(row, container.firstChild);
                }

                const input = row.querySelector('input');
                if (input) {
                    input.focus();
                    const cleanup = () => row.remove();
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const name = (input.value || '').trim();
                            if (!name) {
                                cleanup();
                                return;
                            }
                            createFile(isSource ? 'source' : 'target', server, currentPath, name);
                            cleanup();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            cleanup();
                        }
                    });
                    input.addEventListener('blur', () => cleanup(), { once: true });
                }
            }

            function positionContextMenu(x, y) {
                if (!contextMenu) return;
                const rect = contextMenu.getBoundingClientRect();
                const menuWidth = rect.width || 180;
                const menuHeight = rect.height || 90;
                const padding = 8;
                let left = x;
                let top = y;

                if (left + menuWidth > window.innerWidth - padding) {
                    left = window.innerWidth - menuWidth - padding;
                }
                if (top + menuHeight > window.innerHeight - padding) {
                    top = window.innerHeight - menuHeight - padding;
                }

                const finalLeft = Math.max(padding, left);
                const finalTop = Math.max(padding, top);

                contextMenu.style.left = `${finalLeft}px`;
                contextMenu.style.top = `${finalTop}px`;

                if (typeof window !== 'undefined') {
                    window.downloadWinAnchor = { x: finalLeft, y: finalTop };
                }
            }

            function showContextMenu(e, isSource) {
                const containerId = isSource ? 'sourceFileBrowser' : 'targetFileBrowser';
                const server = document.getElementById(isSource ? 'sourceServer' : 'targetServer').value;
                const container = document.getElementById(containerId);

                if (!contextMenu || !container || !e.target.closest(`#${containerId}`)) return;
                if (!server) return;

                e.preventDefault();
                hideContextMenu();

                const row = e.target.closest('.file-item.selectable');
                contextState = { isSource, targetRow: row || null };

                if (row) {
                    selectRowForContext(row, isSource);
                    if (renameAction) renameAction.classList.remove('disabled');
                } else if (renameAction) {
                    renameAction.classList.add('disabled');
                }

                const canRun = row && String(row.dataset.isDirectory).toLowerCase() !== 'true' && isRunnableFileName(row.dataset.name);
                if (runAction) {
                    if (canRun) {
                        runAction.classList.remove('disabled');
                    } else {
                        runAction.classList.add('disabled');
                    }
                }
                const totalSelectedFiles = selectedSourceFiles.filter(f => !f.is_directory).length + selectedTargetFiles.filter(f => !f.is_directory).length;
                if (compareAction) {
                    if (totalSelectedFiles >= 2) {
                        compareAction.classList.remove('disabled');
                    } else {
                        compareAction.classList.add('disabled');
                    }
                }

                const currentPath = getActivePath(isSource);
                if (newFileAction) {
                    if (currentPath) {
                        newFileAction.classList.remove('disabled');
                    } else {
                        newFileAction.classList.add('disabled');
                    }
                }
                if (newFolderAction) {
                    if (currentPath) {
                        newFolderAction.classList.remove('disabled');
                    } else {
                        newFolderAction.classList.add('disabled');
                    }
                }

                if (sizeAction) {
                    if (row) {
                        sizeAction.classList.remove('disabled');
                    } else {
                        sizeAction.classList.add('disabled');
                    }
                }

                if (compressAction) {
                    if (row) {
                        compressAction.classList.remove('disabled');
                    } else {
                        compressAction.classList.add('disabled');
                    }
                }
                if (extractAction) {
                    const canExtract = row && isArchiveFile(row.dataset.name || '');
                    if (canExtract) {
                        extractAction.classList.remove('disabled');
                    } else {
                        extractAction.classList.add('disabled');
                    }
                }

                if (downloadWindowsAction) {
                    const leftSelected = selectedSourceFiles.length > 0;
                    const rightSelected = selectedTargetFiles.length > 0;
                    const hasWindows = (() => {
                        try {
                            return Object.keys(SERVERS_DATA || {}).some(ip => SERVERS_DATA[ip] && SERVERS_DATA[ip].os_type === 'windows');
                        } catch (_) {
                            return false;
                        }
                    })();
                    const canDownload = hasWindows && (leftSelected || rightSelected) && !(leftSelected && rightSelected);
                    if (canDownload) {
                        downloadWindowsAction.classList.remove('disabled');
                    } else {
                        downloadWindowsAction.classList.add('disabled');
                    }
                }

                contextMenu.style.display = 'block';
                positionContextMenu(e.clientX, e.clientY);
                contextMenu.dataset.visible = 'true';
            }

            if (renameAction) {
                renameAction.addEventListener('click', () => {
                    if (renameAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    const { isSource, targetRow } = contextState;
                    if (targetRow) {
                        startInlineRename(targetRow, isSource);
                    } else {
                        showRenameDialog(isSource ? 'source' : 'target');
                    }
                });
            }

            if (newFolderAction) {
                newFolderAction.addEventListener('click', () => {
                    if (newFolderAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    startInlineCreate(contextState.isSource);
                });
            }

            if (newFileAction) {
                newFileAction.addEventListener('click', () => {
                    if (newFileAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    startInlineCreateFile(contextState.isSource);
                });
            }

            if (compareAction) {
                compareAction.addEventListener('click', () => {
                    if (compareAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    compareFromSelection();
                });
            }

            if (runAction) {
                runAction.addEventListener('click', () => {
                    if (runAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    const { isSource, targetRow } = contextState;
                    if (!targetRow) {
                        addLogWarning('âš ï¸ è¯·é€‰æ‹©è¦è¿è¡Œçš„ .py æˆ– .sh æ–‡ä»¶');
                        return;
                    }
                    const isDir = String(targetRow.dataset.isDirectory).toLowerCase() === 'true';
                    const fileName = targetRow.dataset.name || '';
                    if (isDir || !isRunnableFileName(fileName)) {
                        addLogWarning('âš ï¸ ä»…æ”¯æŒè¿è¡Œ .py æˆ– .sh æ–‡ä»¶');
                        return;
                    }
                    const server = document.getElementById(isSource ? 'sourceServer' : 'targetServer').value;
                    runFileOnServer(server, targetRow.dataset.path, fileName);
                });
            }

            if (sizeAction) {
                sizeAction.addEventListener('click', () => {
                    if (sizeAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    const { isSource, targetRow } = contextState;
                    if (!targetRow) {
                        addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                        return;
                    }
                    const server = document.getElementById(isSource ? 'sourceServer' : 'targetServer').value;
                    const name = targetRow.dataset.name || '';
                    computeSizeOnServer(server, targetRow.dataset.path, name);
                });
            }

            if (compressAction) {
                compressAction.addEventListener('click', () => {
                    if (compressAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    const { isSource, targetRow } = contextState;
                    if (!targetRow) {
                        addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹');
                        return;
                    }
                    const server = document.getElementById(isSource ? 'sourceServer' : 'targetServer').value;
                    const name = targetRow.dataset.name || '';
                    addLogInfo(`ğŸ—œï¸ æ­£åœ¨å‹ç¼©: ${name}`);
                    computeSizeOnServer(server, targetRow.dataset.path, name);
                    compressPathOnServer(server, targetRow.dataset.path, name);
                });
            }

            if (extractAction) {
                extractAction.addEventListener('click', () => {
                    if (extractAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    const { isSource, targetRow } = contextState;
                    if (!targetRow) {
                        addLogWarning('âš ï¸ è¯·å…ˆé€‰æ‹©å‹ç¼©æ–‡ä»¶');
                        return;
                    }
                    const server = document.getElementById(isSource ? 'sourceServer' : 'targetServer').value;
                    const name = targetRow.dataset.name || '';
                    if (!isArchiveFile(name)) {
                        addLogWarning('âš ï¸ ä»…æ”¯æŒ zip/tar/tgz/tar.gz/tar.bz2/tar.xz');
                        return;
                    }
                    addLogInfo(`ğŸ“‚ æ­£åœ¨è§£å‹: ${name}`);
                    extractArchiveOnServer(server, targetRow.dataset.path, name);
                });
            }


            if (downloadWindowsAction) {
                downloadWindowsAction.addEventListener('click', () => {
                    if (downloadWindowsAction.classList.contains('disabled')) return;
                    hideContextMenu();
                    openDownloadToWindowsModal();
                });
            }

            if (sourceContainer) {
                sourceContainer.addEventListener('contextmenu', (e) => showContextMenu(e, true));
                sourceContainer.addEventListener('scroll', hideContextMenu, { passive: true });
            }
            if (targetContainer) {
                targetContainer.addEventListener('contextmenu', (e) => showContextMenu(e, false));
                targetContainer.addEventListener('scroll', hideContextMenu, { passive: true });
            }

            document.addEventListener('click', (evt) => {
                if (contextMenu && contextMenu.dataset.visible === 'true' && !evt.target.closest('#fileContextMenu')) {
                    hideContextMenu();
                }
            });
            document.addEventListener('scroll', hideContextMenu, true);
            window.addEventListener('resize', hideContextMenu);
            document.addEventListener('keydown', (evt) => {
                if (evt.key === 'Escape') {
                    hideContextMenu();
                }
            });

            // ç‚¹å‡»ç©ºç™½åŒºåŸŸæ¸…ç©ºé€‰æ‹©
            function bindEmptyClick(container, isSource) {
                if (!container) return;
                container.addEventListener('click', (e) => {
                    const row = e.target.closest('.file-item.selectable');
                    if (row) return;
                    clearSelectionsForPanel(isSource);
                    updateSelectionInfo();
                    lastActivePanel = isSource ? 'source' : 'target';
                });
            }
            bindEmptyClick(sourceContainer, true);
            bindEmptyClick(targetContainer, false);
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
            document.addEventListener('DOMContentLoaded', function() {
                addLogInfo('ğŸš€ TurboFile æé€Ÿä¼ æ–‡ä»¶ä¼ è¾“ç³»ç»Ÿå·²å¯åŠ¨');
                addLogInfo('ğŸ“‹ è¯·é€‰æ‹©æºæœåŠ¡å™¨å’Œç›®æ ‡æœåŠ¡å™¨å¼€å§‹ä¼ è¾“');
                addLogInfo('ğŸ’¡ æç¤º: ä¼ è¾“è¿‡ç¨‹ä¸­è¯¦ç»†è¿›åº¦ä¿¡æ¯å°†ä¸åœ¨æ—¥å¿—ä¸­æ˜¾ç¤ºä»¥ä¿æŒæœ€ä½³æ€§èƒ½');
                addLogInfo(`âš¡ åŒå‡»ä¼˜åŒ–: æ—¶é—´çª—å£${DOUBLE_CLICK_CONFIG.timeWindow}msï¼Œå“åº”æ›´å®½å®¹å‹å¥½`);
                addLogInfo('ğŸ¯ äº¤äº’ä¼˜åŒ–: ç«‹å³è§†è§‰åé¦ˆï¼Œæ— åŠ¨ç”»å»¶è¿Ÿï¼Œé™æ€æ‚¬åœæ•ˆæœ');
                setupImageWheelZoom();
                const CLIENT_IPV4 = JSON.parse('{{ client_ipv4|tojson|default("null") }}');
                window.CLIENT_IPV4 = CLIENT_IPV4;
                if (CLIENT_IPV4) { addLogInfo('ğŸ–¥ï¸ è®¿é—®è®¾å¤‡ IPv4: ' + CLIENT_IPV4); }
                if (CLIENT_IPV4) {
                    socket.emit('register_client', { client_ip: CLIENT_IPV4 });
                }
            socket.on('connect', () => {
                socketId = socket.id;
                updateRunControls();
            });
            updateRunControls();
            socket.on('connect', () => {
                socketId = socket.id;
                updateRunControls();
            });
            updateRunControls();

            // é»˜è®¤ä½¿ç”¨æ ‡é¢˜å¹¶æ’æ¨¡å¼ï¼Œæ‚¨å¯ä»¥è°ƒç”¨ switchLogoDisplay('watermark') æˆ– switchLogoDisplay('footer') åˆ‡æ¢
            switchLogoDisplay('header');

            // åˆå§‹åŒ–é¢æ¿è°ƒæ•´åŠŸèƒ½
            initializeResizers();
            bindContextMenus();

            // å¤§ç›®å½•æ»šåŠ¨æ‡’åŠ è½½
            const sourceContainer = document.getElementById('sourceFileBrowser');
            if (sourceContainer) {
                sourceContainer.addEventListener('scroll', () => handleScrollLoadMore(true), { passive: true });
            }
            const targetContainer = document.getElementById('targetFileBrowser');
            if (targetContainer) {
                targetContainer.addEventListener('scroll', () => handleScrollLoadMore(false), { passive: true });
            }

            // æœåŠ¡å™¨é€‰æ‹©å˜åŒ–æ—¶è‡ªåŠ¨æµè§ˆ
            document.getElementById('sourceServer').addEventListener('change', async function() {
                if (this.value) {
                    const isWindows = isWindowsServer(this.value);

                    // å…ˆç¡®å®šé»˜è®¤è·¯å¾„å¹¶ç«‹å³å¼€å§‹æµè§ˆï¼ˆé›¶å»¶è¿Ÿï¼‰
                    const defaultPath = getDefaultPathWithRemember(this.value, true);
                    if (!defaultPath) {
                        addLogWarning('âš ï¸ æœªé…ç½®é»˜è®¤è·¯å¾„ï¼Œè¯·æ£€æŸ¥é…ç½®æ–‡ä»¶');
                        return;
                    }
                    currentSourcePath = defaultPath;
                    browseSourceInstant(currentSourcePath);

                    // Windowsç£ç›˜åˆ—è¡¨å¼‚æ­¥åŠ è½½ï¼Œä¸é˜»å¡æ–‡ä»¶æ˜¾ç¤º
                    if (isWindows) {
                        loadWindowsDrives(this.value, true);
                        addLogInfo('ğŸ’¡ æ£€æµ‹åˆ°WindowsæœåŠ¡å™¨ï¼Œæ­£åœ¨åŠ è½½ç£ç›˜åˆ—è¡¨...');
                    } else {
                        hideWindowsDriveSelector(true);
                    }
                }
            });

            document.getElementById('targetServer').addEventListener('change', async function() {
                if (this.value) {
                    const isWindows = isWindowsServer(this.value);

                    // å…ˆç¡®å®šé»˜è®¤è·¯å¾„å¹¶ç«‹å³å¼€å§‹æµè§ˆï¼ˆé›¶å»¶è¿Ÿï¼‰
                    const defaultPath = getDefaultPathWithRemember(this.value, false);
                    if (!defaultPath) {
                        addLogWarning('âš ï¸ æœªé…ç½®é»˜è®¤è·¯å¾„ï¼Œè¯·æ£€æŸ¥é…ç½®æ–‡ä»¶');
                        return;
                    }
                    currentTargetPath = defaultPath;
                    browseTargetInstant(currentTargetPath);

                    // Windowsç£ç›˜åˆ—è¡¨å¼‚æ­¥åŠ è½½ï¼Œä¸é˜»å¡æ–‡ä»¶æ˜¾ç¤º
                    if (isWindows) {
                        loadWindowsDrives(this.value, false);
                        addLogInfo('ğŸ’¡ æ£€æµ‹åˆ°WindowsæœåŠ¡å™¨ï¼Œæ­£åœ¨åŠ è½½ç£ç›˜åˆ—è¡¨...');
                    } else {
                        hideWindowsDriveSelector(false);
                    }
                }
            });

                // è‡ªåŠ¨æ¢å¤ä¸Šæ¬¡æµè§ˆçš„æœåŠ¡å™¨å’Œè·¯å¾„ï¼ˆå¦‚æœå·²è®°å½•ï¼‰
                applyRememberedSelections();


        });
    </script>

    <!-- æç®€å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† -->
    <div id="imagePreviewModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1050;">
        <div style="position:absolute; top:14px; right:18px; z-index:1201; display:flex; gap:8px;">
            <button id="imagePreviewCloseBtn" type="button" class="btn btn-sm btn-outline-light" onclick="closeImageModal()" style="padding:4px 10px;">å…³é—­</button>
        </div>
        <div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center;">
            <img src="" alt="é¢„è§ˆ" style="max-width: 98vw; max-height: 95vh; object-fit: contain; display:block; transition: transform 120ms ease; transform-origin: center center;" />
        </div>
        <button id="imagePrevBtn" aria-label="ä¸Šä¸€å¼ " title="ä¸Šä¸€å¼ "
                style="position:absolute; left:20px; top:50%; transform: translateY(-50%); width:48px; height:48px; border:none; border-radius:50%; background:rgba(255,255,255,0.2); color:#fff; font-size:24px; cursor:pointer;">â€¹</button>
        <button id="imageNextBtn" aria-label="ä¸‹ä¸€å¼ " title="ä¸‹ä¸€å¼ "
                style="position:absolute; right:20px; top:50%; transform: translateY(-50%); width:48px; height:48px; border:none; border-radius:50%; background:rgba(255,255,255,0.2); color:#fff; font-size:24px; cursor:pointer;">â€º</button>
        <div id="imagePreviewCaption" style="position:absolute; bottom:18px; left:50%; transform: translateX(-50%); color:#fff; font-size:14px; background:rgba(0,0,0,0.35); padding:6px 10px; border-radius:10px;"></div>
    </div>

	    <!-- å›¾ç‰‡ç½‘æ ¼è§†å›¾ -->
	    <div id="imageGridModal" style="display:none; position:fixed; inset:0; background:#11161f; z-index:1060; overflow:auto; padding:16px;">
	        <div class="image-grid-header">
	            <div class="image-grid-header-left">
	                <div class="image-grid-title">å›¾ç‰‡ç½‘æ ¼è§†å›¾</div>
	                <div class="image-grid-cols-control" aria-label="é€‰æ‹©åˆ—æ•°">
	                    <span class="image-grid-cols-label">åˆ—æ•°</span>
	                    <div class="image-grid-cols-buttons" id="imageGridColsButtons">
	                        <button type="button" class="image-grid-cols-btn" data-cols="4">4åˆ—</button>
	                        <button type="button" class="image-grid-cols-btn" data-cols="6">6åˆ—</button>
	                        <button type="button" class="image-grid-cols-btn active" data-cols="8">8åˆ—</button>
	                        <button type="button" class="image-grid-cols-btn" data-cols="10">10åˆ—</button>
	                        <button type="button" class="image-grid-cols-btn" data-cols="12">12åˆ—</button>
	                    </div>
	                </div>
	            </div>
	            <div>
	                <button class="btn btn-sm btn-outline-light image-grid-close-btn" onclick="closeImageGrid()" style="margin-right:6px;">å…³é—­</button>
	            </div>
	        </div>
	        <div id="imageGridContainer"></div>
	    </div>

    <!-- æ–‡ä»¶å¯¹æ¯”æ¨¡æ€æ¡†ï¼ˆVSCodeé£æ ¼ï¼‰ -->
    <div id="diffModal">
        <div class="diff-dialog">
            <div class="diff-header">
                <div class="paths">
                    <span id="diffLeftPath"></span>
                    <i class="bi bi-arrow-left-right text-secondary"></i>
                    <span id="diffRightPath"></span>
                </div>
                <button class="diff-close-btn" type="button" onclick="closeDiffModal()">å…³é—­</button>
            </div>
            <div class="diff-body">
                <div class="diff-grid" id="diffGrid">
                    <div class="diff-rows" id="diffRows">
                        <!-- åŠ¨æ€å¡«å…… -->
                    </div>
                </div>
                <div class="diff-summary" id="diffSummary"></div>
            </div>
        </div>
    </div>

    <!-- è½»é‡çº§åœ¨çº¿ç¼–è¾‘å™¨æ¨¡æ€æ¡† -->
<div id="editorModal" class="editor-modal">
        <div class="editor-dialog">
            <div class="editor-header">
                <strong class="modal-title" style="font-size: 0.95rem;">åœ¨çº¿ç¼–è¾‘</strong>
                <div>
                    <button class="btn btn-sm btn-outline-light" onclick="showFindReplace(false)" style="margin-right:6px;">æŸ¥æ‰¾</button>
                    <button class="btn btn-sm btn-outline-light" onclick="showFindReplace(true)" style="margin-right:10px;">æ›¿æ¢</button>
                    <button class="btn btn-sm btn-primary" onclick="saveEditorContent()" style="margin-right:6px;">ä¿å­˜</button>
                    <button class="btn btn-sm btn-danger" onclick="closeEditorModal()">å…³é—­</button>
                </div>
            </div>
                <div class="editor-body">
                <div class="editor-main" style="position: relative;">
                    <div class="editor-text-wrapper">
                        <pre id="editorHighlightLayer" class="editor-highlight-layer"></pre>
                        <textarea class="editor-textarea" wrap="off" id="editorTextarea"></textarea>
                    </div>
                    <div id="findReplaceBar" class="find-replace-bar">
                        <input id="findInput" type="text" placeholder="æŸ¥æ‰¾ (Ctrl+F)" style="min-width: 260px;" />
                        <span id="findCount" style="color:#9ca3af; font-size:12px; min-width:60px; display:inline-block;"></span>
                        <input id="replaceInput" type="text" placeholder="æ›¿æ¢ (Ctrl+H)" style="display:none; min-width: 260px;" />
                        <button class="secondary" onclick="findPrev()">ä¸Šä¸€ä¸ª</button>
                        <button class="secondary" onclick="findNext()">ä¸‹ä¸€ä¸ª</button>
                        <button id="replaceBtn" class="secondary" style="display:none;" onclick="replaceOne()">æ›¿æ¢</button>
                        <button id="replaceAllBtn" style="display:none;" onclick="replaceAll()">å…¨éƒ¨æ›¿æ¢</button>
                        <button class="secondary" onclick="hideFindReplace()">å…³é—­</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

</body>
</html>